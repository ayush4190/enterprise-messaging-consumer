const fs = require('fs').promises;
const path = require('path');

const {fse, yaml} = require('@sap/cds-foss')
const JSONC = require('../../util/jsonc');

const UTF_8 = 'utf-8';

/**
 * this util implements FsUtil declared in ../types.d.ts
 * the interface FsUtil is also used by @sap/generator-cap-project
 */
module.exports = class FsUtil {

    constructor() {
        this.touchedFiles = new Set();
    }

    async writeFile(filepath, content, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(filepath);
        }
        await fse.outputFile(filepath, content, UTF_8);
    }

    async writeJSON(filepath, object, options = { spaces: 2 }, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(filepath);
        }
        await fse.outputJSON(filepath, object, options);
    }

    async writeYAML(filepath, yaml, skipFileLog = false) {
        await this.writeFile(filepath, String(yaml), skipFileLog);
    }

    async readFile(src) {
        return await fs.readFile(src, UTF_8);
    }

    async readJSON(src, projectDescriptor) {
        const file = await this.readFile(src);
        if (projectDescriptor) {
            const Mustache = require('mustache');
            const renderedFile = Mustache.render(file, projectDescriptor);
            return JSON.parse(renderedFile);
        }
        return await fse.readJSON(src);
    }

    async readJSONC(src) {
        const fileContents = await this.readFile(src);
        return JSONC.parse(fileContents);
    }

    async readYAML(src, projectDescriptor) {
        const file = await this.readFile(src);
        if (projectDescriptor) {
            const Mustache = require('mustache');
            const renderedFile = Mustache.render(file, projectDescriptor);
            return yaml.parseDocument(renderedFile);
        }
        return yaml.parseDocument(file);
    }

    async copy(source, destination, options = {}, skipFileLog = false) {
        if (!skipFileLog) {
            this._addTouchedFile(destination);
        }
        await fse.copy(source, destination, options);
    }

    async pathExists(filePath) {
        return await fse.pathExists(filePath);
    }

    async readdir(filePath) {
        return await fs.readdir(filePath);
    }

    getTouchedFiles() {
        return Array.from(this.touchedFiles.keys());
    }

    async mkdirp(folderPath) {
        await fse.mkdirp(folderPath);
    }

    async stat(filePath) {
        return await fs.stat(filePath);
    }

    async hasContent(folderPath) {
        if (await this.pathExists(folderPath)) {
            const projectContent = await this.readdir(folderPath);
            return projectContent.length > 0;
        }

        return false;
    }

    _addTouchedFile(filepath) {
        const relativeFilepath = path.relative('', filepath);
        this.touchedFiles.add(relativeFilepath);
    }
}
