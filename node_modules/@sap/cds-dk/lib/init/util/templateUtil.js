const path = require('path');
const YAML = require('@sap/cds-foss')('yaml');
const Mustache = require('mustache');

const TEMPLATE_EXTENSION = '.hbs';
const TEMPLATE_EXTENSION_REGEX = new RegExp(`${TEMPLATE_EXTENSION}$`);

module.exports = class TemplateUtil {

    constructor(templateRoot, fsUtil) {
        this.templateRoot = templateRoot;
        this.fsUtil = fsUtil;
    }

    async copyFiles(template, destinationPath, templateValues, overwrite = false) {
        const templatePath = this._getTemplatePath(template);

        const files = await this.fsUtil.readdir(templatePath);
        for (const file of files) {
            const fileNew = Mustache.render(file, templateValues);
            const src = path.join(templatePath, file);
            const dest = path.join(destinationPath, fileNew);

            const stat = await this.fsUtil.stat(src);
            if (stat.isDirectory()) {
                await this.copyFiles(path.join(template, file), dest, templateValues, overwrite);
            } else if (this._isTemplateFile(file)) {
                await this._writeTemplateFile(src, dest, templateValues, overwrite);
            } else {
                await this.fsUtil.copy(src, dest);
            }
        }
    }

    async sortDependencies(packageJSONPath) {
        const json = await this.fsUtil.readJSON(packageJSONPath);
        json.dependencies = Object.fromEntries(
            Object.entries(json.dependencies).sort(([a],[b]) => a>b ? 1 : -1)
        )
        await this.fsUtil.writeJSON(packageJSONPath, json);
    }

    async _writeTemplateFile(src, destination, templateValues, overwrite = false) {
        const destinationPath = destination.replace(TEMPLATE_EXTENSION_REGEX, '');
        if (overwrite || !(await this.fsUtil.pathExists(destinationPath))) {
            const content = await this._processTemplateFile(src, templateValues);
            await this.fsUtil.writeFile(destinationPath, content);
        }
    }

    async _processTemplateFile(src, templateValues) {
        const content = await this.fsUtil.readFile(src);
        return Mustache.render(content, templateValues);
    }

    _getTemplatePath(templatePath) {
        return path.join(this.templateRoot, templatePath);
    }

    _isTemplateFile(filename) {
        return path.extname(filename) === TEMPLATE_EXTENSION;
    }

    /*
    Will do a syntactic merge when `semantics` is undefined.
    Syntactic merges are sufficient in some cases,
    e.g merging dependencies in a package.json, as they are
    just maps where you can do a key-value replacement.
    */
    _deepMerge(target, source) {
        if (this._isObject(target) && this._isObject(source)) {
            for (const key in source) {
                if (this._isObject(source[key])) {
                    if (!target[key]) Object.assign(target, { [key]: source[key] });
                    if ('#overwrite' in source[key]) Object.assign(target, { [key]: source[key]["#overwrite"] })
                    else this._deepMerge(target[key], source[key]);
                } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
                    const unique = array => [...new Set(array.map(JSON.stringify))].map(JSON.parse);
                    target[key] = unique([...source[key], ...target[key]])
                } else {
                    Object.assign(target, { [key]: target[key] || source[key] });
                }
            }
        } else if (Array.isArray(target) && Array.isArray(source)) {
            const unique = array => [...new Set(array.map(JSON.stringify))].map(JSON.parse);
            target = unique([...source, ...target])
        }
        return target || source;
    }

    async mergeJSON(targetPath, from, projectDescriptor, semantics) {
        const source = typeof from === 'string' ? await this.fsUtil.readJSON(from, projectDescriptor) : from

        if (! await this.fsUtil.pathExists(targetPath)) {
            await this.fsUtil.writeJSON(targetPath, source);
        } else if (semantics) {
            const target = await this.fsUtil.readJSON(targetPath)

            if (!target) return // Has no JSON file

            const targetYAML = await YAML.parseDocument(YAML.stringify(target))
            const sourceYAML = await YAML.parseDocument(YAML.stringify(source))
            const resultYAML = await this.mergeYAML(targetYAML, sourceYAML, projectDescriptor, semantics)
            const result = YAML.parse(YAML.stringify(resultYAML))
            await this.fsUtil.writeJSON(targetPath, result)
        } else {
            const target = await this.fsUtil.readJSON(targetPath);
            const sourceFile = await this._processTemplateFile(from, projectDescriptor);
            const source = JSON.parse(sourceFile);
            const result = target && source ? this._deepMerge(target, source) : target || source;
            await this.fsUtil.writeJSON(targetPath, result);
        }
    }

    async mergeYAML(into, from, projectDescriptor, semantics) {
        const target = typeof into === 'string' ? await this.fsUtil.readYAML(into) : into
        const source = typeof from === 'string' ? await this.fsUtil.readYAML(from, projectDescriptor) : from

        if (!target || !target.contents) return // Has no YAML file

        const existenceMap = new Map()
        const templateExistenceMap = new Map()

        const existences = semantics.existences && semantics.existences.filter(e => e)

        existences && existences.forEach(existence => {
            existenceMap.set(existence.ref, undefined)
            templateExistenceMap.set(existence.ref, undefined)
        });

        const { deletions } = semantics
        deletions && deletions.forEach(deletion => {
            existenceMap.set(deletion.existence.ref, undefined)
        })

        const missingRelationshipsMap = new Map()

        const relationships = semantics.relationships && semantics.relationships.filter(r => r)
        relationships && relationships.forEach(relationship =>
            missingRelationshipsMap.set(relationship.in.ref, undefined)
        )

        let collectionStack = [target.contents]

        const _getProperty = (object, keyPath) => keyPath.reduce((p, n) => p && p[n], object)
        const _getYAMLProperty = (object, keyPath) => keyPath.reduce((p, n) => p && p.get(n), object)

        const _validateConstraints = (node, dict, index) => {
            const _addToMap = existences => existences
                .filter(existence => {
                    if (!existence.in) return true
                    const neededParent = existence.in && dict.get(existence.in.ref) && dict.get(existence.in.ref).node
                    return collectionStack.includes(neededParent)
                })
                .forEach(existence => {
                    const json = JSON.parse(String(node));
                    const constraintsFulfilled = existence.constraints.every(constraint =>
                        constraint.value === _getProperty(json, constraint.comparisonKeyPath)
                    )
                    if (constraintsFulfilled) {
                        const [collection] = collectionStack
                        dict.set(existence.ref, { json, node, index, collection })
                    }
            })
            _addToMap(existences)
            deletions && _addToMap(deletions.map(deletion => deletion.existence))
        }

        function _traverseYAMLNode(node, index, actions, templateNode) {
            let shifted = false
            switch (node.type) {
                case 'MAP': {
                    actions && actions.visitMap && actions.visitMap(node, index)
                    const [collection] = collectionStack
                    if (collection && collection.type === 'SEQ') { collectionStack.unshift(node); shifted = true}
                    break;
                }
                case 'SEQ':
                    break;
                case 'PAIR':
                    if (node.value && node.value.items) collectionStack.unshift(node.value)
                    break;
                case 'PLAIN':
                    break;
            }

            if (node.items) {
                if ((node.type === 'SEQ' || node.type === 'FLOW_SEQ') && templateNode && templateNode.items) {
                    actions.mergeCollection && actions.mergeCollection(node, templateNode)
                    node.type === 'SEQ' && _traverseYAMLCollection(node, actions, templateNode)
                } else {
                    _traverseYAMLCollection(node, actions, templateNode)
                }
            } else if (node.value && node.value.items) {
                _traverseYAMLNode(node.value, index, actions, templateNode && templateNode.value)
            }

            if (node.value && node.value.items || shifted) {
                collectionStack.shift()
            }
        }
        _traverseYAMLNode.bind(this)

        const _traverseYAMLCollection = (collection, actions, templateCollection) => {
            if (!collection) return

            const keyIndexMap = new Map()
            const templateIndexMap = new Map()

            // Map collection items to their semantic counterpart(s)
            collection.items.forEach((node, i) => {
                if (node.key) keyIndexMap.set(node.key.value, i)
                const existence = [...existenceMap.entries()].find(([,value]) => value && value.node === node)
                if (existence) {
                    const [existenceKey] = existence
                    const templateExistence = existenceKey && templateExistenceMap.get(existenceKey)
                    const templateIndex = templateExistence && templateExistence.index
                    if (templateIndex !== undefined) templateIndexMap.set(templateIndex, i)
                }
                if (!templateCollection) _traverseYAMLNode(node, i, actions)
            });

            if (!templateCollection) return

            templateCollection.items.forEach((templateNode, templateIndex) => {
                if (templateNode.type === 'PAIR') {
                    const i = keyIndexMap.get(templateNode.key.value)
                    const [collection] = collectionStack
                    const targetNode = collection.items && collection.items[i]
                    if (targetNode) {
                        _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                    } else if (actions.mergePair) {
                        actions.mergePair(collection, templateNode)
                    }
                } else if (templateNode.type === 'MAP') {
                    const targetNode = collection.items[templateIndexMap.get(templateIndex)]
                    if (actions.mergeCollection) actions.mergeCollection(targetNode, templateNode)
                    if (targetNode) {
                        _traverseYAMLNode(targetNode, templateIndex, actions, templateNode);
                    }
                }
            })
        }
        _traverseYAMLCollection.bind(this)

        // 1. Validate the existences in the template
        _traverseYAMLNode(source.contents, null, {
            visitMap: (node, index) => {
                _validateConstraints(node, templateExistenceMap, index)
            }
        })

        // 2. Validate the existences in the project
        _traverseYAMLNode(target.contents, null, {
            visitMap: (node, index) => {
                _validateConstraints(node, existenceMap, index)
            }
        })

        // 3. Apply overwrites to already found existences
        semantics.overwrites && semantics.overwrites.forEach(({ in: inExistence, keyPath, replacement }) => {
            const existence = existenceMap.get(inExistence.ref)
            if (existence) {
                _getYAMLProperty(existence.node, keyPath.slice(0, keyPath.length - 1))
                    .set(keyPath[keyPath.length - 1], replacement)
            }
        })

        // 4. Delete existences from the project (e.g. separate deployer module when adding mtx)
        semantics.deletions && semantics.deletions.forEach(({ existence: { ref }, relationships }) => {
            const existence = existenceMap.get(ref)
            if (!existence) return
            existence.collection.delete(existence.index)

            relationships && relationships.forEach(relationship => {
                const parent = target.get(relationship.allWithinKeyPath[0])
                for (const child of parent.items) {
                    const c = child.get(relationship.inKeyPath[0])
                    const i = c.items.findIndex(node =>
                        node.get(relationship.into) === _getProperty(existence.json, relationship.existenceKeyPath)
                    )
                    if (i > -1) {
                        c.delete(i)
                    }
                }
            })
        })

        // 5. Create missing existences and pairs
        _traverseYAMLNode(target.contents, null, {
            mergePair: (collection, templateNode) => {
                const childIsArray = false//templateNode.value.type !== 'MAP' && !!templateNode.value.items
                if (collection.type === 'MAP' && !childIsArray) {
                    collection.add(templateNode)
                    //this.fsUtil.writeYAML(targetPath, target)
                }
            },
            mergeCollection: (targetNode, templateNode) => {
                if (templateNode.type === 'SEQ' || templateNode.type === 'FLOW_SEQ') {
                    const [,parent] = collectionStack
                    const missingExistences = semantics.existences
                        .filter(e => e)
                        .filter(existence => {
                            const requiredParent = existence.in &&
                                                   existenceMap.get(existence.in.ref) &&
                                                   existenceMap.get(existence.in.ref).node
                            return !existence.in || requiredParent === parent

                        })
                        .filter(({keyPath}) => parent.get(keyPath[0]) === targetNode)
                        .filter(({ref}) => !existenceMap.get(ref))
                    missingExistences.forEach(existence => {
                        const templateNode = templateExistenceMap.get(existence.ref).node
                        templateNode.spaceBefore = existence.spaceBefore
                        targetNode.add(templateNode)
                        //this.fsUtil.writeYAML(targetPath, target)
                    })
                }
            },
        }, source.contents)

        // 6. Re-validate the existences in the project
        _traverseYAMLNode(target.contents, null, {
            visitMap: (node, index) => {
                _validateConstraints(node, existenceMap, index)
            }
        })

        // 7. Create missing relationships
        _traverseYAMLNode(target.contents, null, {
            mergeCollection: (targetNode, templateNode) => {
                if (templateNode.type === 'SEQ') {
                    const targetJSON = YAML.parse(String(targetNode))
                    const relationship = semantics.relationships && semantics.relationships
                        .filter(r => r)
                        .find(relationship => {
                            const existingNode = _getYAMLProperty(existenceMap.get(relationship.in.ref).node, relationship.inKeyPath)
                            return targetNode === existingNode
                    })
                    if (!relationship) return

                    const missingPairs = relationship.existences
                        .filter(({ref}) =>
                            !targetJSON.some(item =>
                                _getProperty(existenceMap.get(ref).json, relationship.existenceKeyPath) === item[relationship.into]
                            )
                        )
                        .map(({ref}) => existenceMap.get(ref).node.get(relationship.into))
                    missingPairs.forEach(pair => {
                        targetNode.add(YAML.createNode({ [relationship.into]: pair }))
                        //await this.fsUtil.writeYAML(targetPath, target)
                    })
                }
            }
        }, source.contents)

        typeof into === 'string' && await this.fsUtil.writeYAML(into, target)
        return target
    }

    _isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item)
    }
};

