const path = require('path');
const Config = require('@sap/cds/lib/env');

const TemplateUtil = require('../util/templateUtil');

const { PROJECT_TYPE } = require('../constants');


module.exports = class TemplateBase {
    /**
     * @constructor
     */
    constructor(projectPath, generator, dirName) {
        if (generator.options && generator.options.for && typeof generator.options.for !== 'string') {
            throw new Error('The --for argument must not be empty.')
        }
        this.options = generator.options || {};
        this.projectPath = path.resolve(projectPath);
        this.fsUtil = generator.fsUtil;
        this.logger = generator.logger;
        this.generator = generator;

        this.cwd = this.options.cwd || process.cwd();
        this.name = this.constructor.name.replace(/template/i, '').toLowerCase();

        this.projectName = path.basename(this.projectPath);
        this.templateUtil = new TemplateUtil(path.join(dirName, 'files'), this.fsUtil);
    }

    /**
     * Returns an array of required templates. These templates will also be added if not already included.
     * Declared async to allow complex calculation of the dependencies.
     * @returns an array with depending templates, might be empty or null
     */
    async getDependencies() {
    }

    /**
     * Checks whether the given template should handle this request
     * @returns true, if template should handle this request, false otherwise
     * @throws Error, if request is invalid, e.g. a file exists already
     */
    async checkEnabled() {
        return true;
    }

    /**
     * calls cds env and caches result
     * @param {boolean} force, ignore cached value
     * @returns {object} the current cds env
     */
    async getEnv() {
        let projectPath;
        if (await this.fsUtil.pathExists(this.projectPath)) {
            projectPath = this.projectPath;
        } else {
            projectPath = this.cwd;
        }

        return Config.for('cds', projectPath);
    }

    /**
     * @abstract
     * Executes the given template's merging steps.
     * The separation from `run()` is necessary to preserve templating associativity,
     * i.e. the order in which you apply them does not matter.
     * Ex.: Assume `cds add hana` is called before `cds add mta`. We want `cds add mta`
     * to create the base mta.yaml template and merge the hana mta.yaml in, but _don't_
     * want any other steps from the hana template performed (e.g. creating the .hdiconfig).
     * Separating the two let's us run this _only_ the merging part of the template.
     */
     async runMTAMerging() {

     }

    /**
     * @abstract
     * Executes the given template.
     * @throws Error, if handling failed.
     */
    async run() {
    }

    /**
     * @abstract
     * Called when generation is finished
     */
    async finalize() {
    }

    /**
     * Returns the project type
     * @see PROJECT_TYPE
     * @returns PROJECT_TYPE for current project
     */
    async getProjectType() {
        if (await this.fsUtil.pathExists(path.join(this.projectPath, 'pom.xml'))) {
            return PROJECT_TYPE.java;
        }

        if (await this.fsUtil.pathExists(path.join(this.projectPath, 'package.json'))) {
            return PROJECT_TYPE.nodejs;
        }

        return PROJECT_TYPE.unknown;
    }
}
