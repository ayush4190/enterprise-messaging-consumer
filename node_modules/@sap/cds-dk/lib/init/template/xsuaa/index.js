const fs = require('fs')
const path = require('path')
const TemplateBase = require('../templateBase')
const ProjectReader = require('../../util/projectReader')
const { srvNode, srvJava, xsuaa } = require('../_merging/existences')
const { PROJECT_TYPE } = require('../../constants');

module.exports = class XsuaaTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname)
        this.projectReader = new ProjectReader(this)
    }

    async runMTAMerging() {
        const projectDescriptor = await this.projectReader.read(this.options)
        const { projectPath } = this

        const mtaYAMLPath = path.join(projectPath, 'mta.yaml')
        if (!fs.existsSync(mtaYAMLPath)) return

        const srv = projectDescriptor.cap.isNodejs ? srvNode : srvJava
        await this.templateUtil.mergeYAML(
            mtaYAMLPath,
            `${__dirname}/files/mta.yaml.hbs`,
            projectDescriptor,
            {
                existences: [srv, xsuaa],
                relationships: [{
                    in: srv,
                    inKeyPath: ["requires"],
                    into: "name",
                    existences: [xsuaa],
                    existenceKeyPath: ["name"],
                }],
            }
        )

        // Re-applying the merging part of `cds add mtx` because cds.compile.to.xsuaa
        // has overwritten the existing `xs-security.json`.
        // TODO: Find a generic solution for situation like these.
        if (projectDescriptor.cap.isMultitenant) {
            const MtxTemplate = require(`../mtx`)
            const mtxTemplate = new MtxTemplate(this.projectPath, this.generator)
            await mtxTemplate.runMTAMerging()
        }
    }

    async run() {
        const { projectPath } = this
        const templatePath = path.join(__dirname, 'files')
        const projectDescriptor = await this.projectReader.read(this.options)

        const projectType = await this.getProjectType();
        switch (projectType) {
            case PROJECT_TYPE.java: {
                const cdsrcJSONPath = path.join(projectPath, '.cdsrc.json')
                const cdsTemplateFile = projectDescriptor.cap.for ? 'cds.cdsrc.json.hbs' : 'cds.cdsrc.json'
                const cdsTemplatePath = path.join(templatePath, cdsTemplateFile)
                await this.templateUtil.mergeJSON(cdsrcJSONPath, cdsTemplatePath, projectDescriptor)
                break
            }
            case PROJECT_TYPE.nodejs: {
                const packageJSONPath = path.join(projectPath, 'package.json')
                const cdsTemplateFile = projectDescriptor.cap.for ? 'cds.package.json.hbs' : 'cds.package.json'
                const cdsTemplatePath = path.join(templatePath, cdsTemplateFile)
                await this.templateUtil.mergeJSON(packageJSONPath, cdsTemplatePath, projectDescriptor)
                const dependenciesTemplatePath = path.join(templatePath, 'dependencies.package.json')
                await this.templateUtil.mergeJSON(packageJSONPath, dependenciesTemplatePath)
                break
            }
        }
        const cds = require('../../../../lib/compile')
        const xsuaa = await (async () => { try {
            const models = await cds.load(path.join(projectPath, cds.env.folders.srv))
            return cds.compile.to.xsuaa(models)
        } catch (error) { /* ignore */ }
        })() || { scopes: [], attributes: [], 'role-templates': [] }

        const mergingSemantics = { existences: xsuaa.scopes.map(scope => ({
            ref: scope.name,
            keyPath: ["scopes"],
            constraints: [{
                comparisonKeyPath: ["name"],
                value: scope.name
            }],
        }))}
        const xsSecurityPath = path.join(projectPath, 'xs-security.json')
        await this.templateUtil.mergeJSON(xsSecurityPath, xsuaa, projectDescriptor, mergingSemantics)
        await this.runMTAMerging()
    }
}
