const { existsSync } = require('fs');
const { join } = require('path');
const TemplateBase = require('../templateBase');
const ProjectReader = require('../../util/projectReader');

module.exports = class MtaTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);
        this.projectReader = new ProjectReader(this);
    }

    async run() {
        const projectDescriptor = await this.projectReader.read();
        if (!existsSync(join(this.projectPath, 'mta.yaml'))) {
            await this.templateUtil.copyFiles('.', this.projectPath, projectDescriptor);
        }

        // Re-applying the merging part of `cds add xsuaa`, `cds add hana`, and `cds add mtx`, if necessary.
        // TODO: Find a generic solution for situation like these. Probably involves some restructuring in the
        // project reader, so that there's a logical mapping from hasX to XTemplate.
        if (projectDescriptor.cap.hasApprouter) {
            const ApprouterTemplate = require(`../approuter`)
            const template = new ApprouterTemplate(this.projectPath, this.generator)
            await template.runMTAMerging()
        }
        if (projectDescriptor.cap.hasHana) {
            const HanaTemplate = require(`../hana`)
            const template = new HanaTemplate(this.projectPath, this.generator)
            await template.runMTAMerging()
        }
        if (projectDescriptor.cap.hasXsuaa) {
            const XsuaaTemplate = require(`../xsuaa`)
            const template = new XsuaaTemplate(this.projectPath, this.generator)
            await template.runMTAMerging()
        }
        if (projectDescriptor.cap.isMultitenant) {
            const MtxTemplate = require(`../mtx`)
            const template = new MtxTemplate(this.projectPath, this.generator)
            await template.runMTAMerging()
        }
    }
};
