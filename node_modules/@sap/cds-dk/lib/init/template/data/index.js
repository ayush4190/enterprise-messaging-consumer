const TemplateBase = require('../templateBase');
const cds = require('@sap/cds');
const {resolve, join, relative}  = require('path');
const fs = require('fs');

module.exports = class DataTemplate extends TemplateBase {
  constructor(projectPath, generator) {
    super(projectPath, generator, __dirname);
  }

  async run() {
    const env = await this.getEnv();

    let dest = (typeof this.options.out === 'string') // target folder
      ? this.options.out
      : getDefaultTargetFolder(env, this.projectPath);
    dest = resolve(this.projectPath, dest);

    const nameFilter = asRegex(this.options.for)
    const force = this.options.force;
    const logger = this.logger;

    cds.root = this.projectPath;
    let csn = await cds.compile.to.csn(cds.env.roots); // normal CSN

    // Also include 'external' entities w/ cds.persistence.skip (similar to 'mocked' option of serve).
    // Could be too much sometimes, but don't want to bother users w/ a separate option for this.
    includeExternalEntities(csn, logger)

    csn = cds.compile.for.sql(csn, { names:env.sql.names, messages:[] })  // CSN w/ persistence information
    csn = cds.reflect(csn); // reflected model (adds additional helper functions)

    csn.all('entity')
      .filter (e => e.name.match(nameFilter)) // --for prefix|regex
      .filter (e => !e.query) // exclude entities with queries (projection on, select from ...)
      .filter (e => e.name !== 'DRAFT.DraftAdministrativeData' && !e.name.endsWith('.drafts')) // exclude draft stuff
      .forEach(e => processEntity(e, dest, this.projectPath, csn, force, logger));
  }
}

function includeExternalEntities(model, logger) {
  for (let each in model.definitions) {
    const def = model.definitions[each]
    if (def['@cds.persistence.skip'] === true) {
      logger.debug ('Including skipped entity '+each)
      delete def['@cds.persistence.skip']
    }
  }
  return model
}

function asRegex(spec) {
  if (typeof spec === 'string') {
    try {
      if (spec.match(/[\^$|*]/))
        return new RegExp(spec)
      else { // no meta chars -> prefix semantics
        spec = spec.replace(/\./g, '\\.') // escape dot
        return new RegExp('^'+spec+'.*')
      }
    } catch (err) {
      throw new Error (err.message) // user error, so cut off stack trace
    }
  }
  return /.*/
}

function processEntity (entity, dest, projectPath, csn, force, logger) {
  let dataFileName;
  const namespace = getNamespace(csn, entity.name);
  if (!namespace || namespace == entity.name) {
    dataFileName = `${entity.name}.csv`;
  }
  else {
    const entityName = entity.name.replace(namespace + '.', '');
    dataFileName = `${namespace}-${entityName}.csv`;
  }

  if (entity.name.endsWith('.texts')) {
    // handle '.texts' entities (for localized elements) differently:
    // if there is already file exist with '_texts' (old cds versions) - overwrite this one (when --force is used)
    // otherwise use the new '.texts' format
    const dataFileNameOldFormat = dataFileName.replace('.texts.csv','_texts.csv');
    const dataFilePathOldFormat = join(dest, dataFileNameOldFormat);
    if (fs.existsSync(dataFilePathOldFormat)) {
      createDataFile(true, dataFilePathOldFormat, dest, projectPath, force, entity, logger);
      return;
    }
  }

  const dataFilePath = join(dest, dataFileName);
  createDataFile(fs.existsSync(dataFilePath), dataFilePath, dest, projectPath, force, entity, logger);
}

function getDefaultTargetFolder (env, projectPath) {
  const dbFolder = env.folders.db;
  // csv files should be located in the 'db/data' folder unless a 'db/csv' folder already exists
  let mockDataFolder;
  if (fs.existsSync(join(projectPath, dbFolder, 'csv'))) {
    mockDataFolder = 'csv';
  } else {
    mockDataFolder = 'data';
  }
  return join(dbFolder, mockDataFolder);
}


function createDataFile (isFileExists, dataFilePath, dest, projectPath, force, entity, logger) {
  let relFilePath = dataFilePath;
  if (dataFilePath.indexOf(projectPath) == 0) {
    // use relative path in log (for readability), only when data files are added within the project
    // (potentially can be located anywhere using the --out parameter)
    relFilePath = relative(projectPath, dataFilePath);
  }
  if (isFileExists && !force) {
    logger.log(`Skipping ${relFilePath}`);
  }
  else {
    // continue only if file not already exists, or '--force' option provided
    const dataFileContent = prepareDataFileContent(entity);
    if (dataFileContent && dataFileContent.length) {
      if (!fs.existsSync(dest))  fs.mkdirSync(dest, {recursive: true})
      fs.writeFileSync(dataFilePath, dataFileContent);
      isFileExists ? logger.log(`Overwriting `+relFilePath) : logger.log(`Creating `+relFilePath)
    }
  }
}

function prepareDataFileContent (entity) {
  const persistenceKeyNames = Object.values(entity.keys||[]).map(element => element['@cds.persistence.name']);
  return Object.values(entity.elements)
    .filter(element => !(element instanceof cds.Association)) // exclude associations+compositions
    .filter(element => !!element['@cds.persistence.name']) // exclude no-persistence elements, e.g. virtual ones
    .map (element => element['@cds.persistence.name'])
    .sort((e1, e2) => { // sort with keys first
      if (persistenceKeyNames.includes(e1)  && !persistenceKeyNames.includes(e2)) return -1
      if (!persistenceKeyNames.includes(e1) && persistenceKeyNames.includes(e2))  return 1
      return 0 // preserve original order otherwise
    })
    .join(';')
}

// Logic is taken from cds-compile
function getNamespace(csn, artifactName) {
  const parts = artifactName.split('.');
  let seen = parts[0];
  const art = csn.definitions[seen];

  // First step is not a namespace (we faked those in the CSN)
  // No subsequent step can be a namespace then
  if (art && art.kind !== 'namespace') {
    return null;
  }


  for (let i = 1; i < parts.length; i++) {
    // This was definitely a namespace so far
    const previousArtifactName = seen;
    seen = `${seen}.${parts[i]}`;
    // This might not be - if it isn't, return the result.
    const currentArtifact = csn.definitions[seen];
    if (currentArtifact && currentArtifact.kind !== 'namespace') {
      return previousArtifactName;
    }
  }
  // We came till here - so the full artifactName is a namespace
  return artifactName;
}
