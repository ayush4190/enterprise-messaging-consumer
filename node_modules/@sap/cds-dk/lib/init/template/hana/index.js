const fs = require('fs');
const path = require('path');

const commandUtil = require('../../util/commandUtil');
const mvnArchetypes = require('../../util/mvnArchetypeUtil');
const term = require('../../../util/term');
const ProjectReader = require('../../util/projectReader');

const TemplateBase = require('../templateBase');

const { PROJECT_TYPE, OPTION_JAVA, URLS, KIND_HANA } = require('../../constants');
const { nullLogger } = require('../../util/logger');
const { srvNode, srvJava, hdbDeployer, serviceManager, hdiContainer } = require('../_merging/existences');

module.exports = class HanaTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);
        this.projectReader = new ProjectReader(this);
    }

    // read env from project
    async getEnv() {
        const cdsEnvVar = process.env.CDS_ENV;
        process.env.CDS_ENV = 'production'
        try {
            return await super.getEnv();
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    async checkEnabled() {
        const { lt } = require('semver')
        const cds = require('@sap/cds/lib')
        if (lt(cds.version, '5.9.0')) {
            cds.error('The added configuration requires @sap/cds 5.9.0 or higher. Please update @sap/cds to the latest version and run \x1b[1mcds add hana\x1b[0m again.')
        }
        return true
    }

    async runMTAMerging() {
        const projectDescriptor = await this.projectReader.read(this.options);

        const mtaYAMLPath = path.join(this.projectPath, 'mta.yaml');

        if (!fs.existsSync(mtaYAMLPath)) return

        const srv = projectDescriptor.cap.isNodejs ? srvNode : srvJava
        const deployer = projectDescriptor.cap.isMultitenant ? null : hdbDeployer
        const db = projectDescriptor.cap.isMultitenant ? serviceManager : hdiContainer
        const deletions = projectDescriptor.cap.isMultitenant ? [{
            existence: hdbDeployer,
            relationships: [{
                allWithinKeyPath: ["modules"],
                inKeyPath: ["requires"],
                into: "name",
                existenceKeyPath: ["name"],
            }]
        }, {
            existence: hdiContainer,
            relationships: [{
                allWithinKeyPath: ["modules"],
                inKeyPath: ["requires"],
                into: "name",
                existenceKeyPath: ["name"],
            }]
        }] : []

        await this.templateUtil.mergeYAML(
            mtaYAMLPath,
            `${__dirname}/files/mta.yaml.hbs`,
            projectDescriptor,
            {
                existences: [srv, deployer, db],
                relationships: [{
                    in: srv,
                    inKeyPath: ["requires"],
                    into: "name",
                    existences: [db],
                    existenceKeyPath: ["name"],
                },
                !projectDescriptor.cap.isMultitenant && projectDescriptor.cap.isNodejs ?
                    {
                        in: deployer,
                        inKeyPath: ["requires"],
                        into: "name",
                        existences: [db],
                        existenceKeyPath: ["name"],
                    } : null],
                deletions
            }
        );
    }

    async run() {
        const env = await this.getEnv();

        const hdiConfigPath = path.join(this.projectPath, env.folders.db, 'src', '.hdiconfig');
        const hdiConfigTemplatePath = path.join(__dirname, 'files', 'common', 'src', '.hdiconfig');
        await this.templateUtil.mergeJSON(hdiConfigPath, hdiConfigTemplatePath);

        const undeployJSONPath = path.join(this.projectPath, env.folders.db, 'undeploy.json');
        const undeployJSONTemplatePath = path.join(__dirname, 'files', 'common', 'undeploy.json');
        await this.templateUtil.mergeJSON(undeployJSONPath, undeployJSONTemplatePath);

        const projectType = await this.getProjectType();
        switch (projectType) {
            case PROJECT_TYPE.java: {
                await this.templateUtil.copyFiles(path.join('java', 'db'), path.join(this.projectPath, env.folders.db), {}, this.options.force);
                await this._updatePomXml();
                const cdsrcJsonPath = path.join(this.projectPath, '.cdsrc.json');
                await this._updateCdsrcJson(cdsrcJsonPath, env.folders.db, env);
                break;
            }
            case PROJECT_TYPE.nodejs:
                await this._updatePackageJson(path.join(this.projectPath, 'package.json'));
                break;

            default: break;
        }
        await this.runMTAMerging()
    }

    async _updatePomXml() {
        // if called during cds init the project generation call to AT will add settings
        if (!this.options.add.has(OPTION_JAVA)) {
            const mvnAddHanaArgs = mvnArchetypes.getAddHanaCmdArgs(this.options);
            try {
                await commandUtil.spawnCommand('mvn', mvnAddHanaArgs, {
                    cwd: this.projectPath
                }, (this.logger.isDebug ? this.logger : nullLogger));
            } catch (err) {
                if (err.code === 'ENOENT' && err.path === 'mvn') {
                    throw new Error(`Maven executable 'mvn' not found, follow ${term.info(URLS.MAVEN_INSTALL_HELP)} and install Maven on your machine.`);
                }
                throw err;
            }
        }
    }

    async _updatePackageJson(packageJsonPath) {
        const projectDescriptor = await this.projectReader.read(this.options);
        const dependenciesTemplatePath = path.join(__dirname, 'files', 'nodejs', 'dependencies.package.json');
        await this.templateUtil.mergeJSON(packageJsonPath, dependenciesTemplatePath);

        const cdsTemplateFile = projectDescriptor.cap.for ? 'cds.profile.package.json.hbs' : 'cds.package.json.hbs';
        const cdsTemplatePath = path.join(__dirname, 'files', 'nodejs', cdsTemplateFile);
        await this.templateUtil.mergeJSON(packageJsonPath, cdsTemplatePath, projectDescriptor);

        const packageJson = await this.fsUtil.readJSON(packageJsonPath);
        if (packageJson.dependencies['@sap/hana-client']) {
            delete packageJson.dependencies['@sap/hana-client'];
            await this.fsUtil.writeJSON(packageJsonPath, packageJson);
        }
    }

    async _updateCdsrcJson(cdsrcJsonPath) {
        const projectDescriptor = await this.projectReader.read(this.options);
        const cdsTemplateFile = projectDescriptor.cap.for ? 'profile.cdsrc.json.hbs' : 'cdsrc.json.hbs';
        const cdsTemplatePath = path.join(__dirname, 'files', 'java', cdsTemplateFile);
        if (!fs.existsSync(cdsrcJsonPath)) {
            this.fsUtil.writeJSON(cdsrcJsonPath, {})
        }
        await this.templateUtil.mergeJSON(cdsrcJsonPath, cdsTemplatePath, projectDescriptor);
    }
}
