/* eslint-disable no-prototype-builtins */
/**
 * OData V4 to CSN parser
 */


'use strict';
let messages = require("./message").getMessages();
let common = require("./common");
let versionInfo = require('../../package.json').version;
let namespace;
let complexTypes = {};
let enumTypes = {};
let typeDefinitions = {};
let unboundedActions = {};
let boundedActions = {};
let unboundedFunctions = {};
let boundedFunctions = {};
let errors = [];
let Multimap = require('../import/utils/MultiMap.js');
let entitySetToEntityTypeMap = new Multimap();
let actionImportToActionMap = new Multimap();
let functionImportToFunctionMap = new Multimap();
let validEdmDatatypes = ['Edm.DateTimeOffset'];
let jsonEntityContainerName;
let entityTypes = [];
const ignoreObjects = ['$Reference']; // add all the objects that needs to be ignored for parsing.
const { warn } = require('@sap/cds/bin/utils/term');

const MetadataConverterFactory = require('../import/utils/MetadataConverterFactory');
const edmxncdsdatatype = {
    'Edm.String': 'cds.LargeString',
    'Edm.Boolean': 'cds.Boolean',
    'Edm.Int16': 'cds.Integer',
    'Edm.Int32': 'cds.Integer',
    'Edm.Int64': 'cds.Integer64',
    'Edm.Decimal': 'cds.DecimalFloat',
    'Edm.DateTimeOffset': 'cds.DateTime',
    'Edm.TimeOfDay': 'cds.Time',
    'Edm.Date': 'cds.Date',
    'Edm.Binary': 'cds.LargeBinary',
    'Edm.Guid': 'cds.UUID',
    'Edm.Byte': 'cds.Integer',
    'Edm.SByte': 'cds.Integer',
    'Edm.Double': 'cds.Double',
    // Special handling of data types
    'Edm.String_m': 'cds.String', // Max length
    'Edm.Decimal_p': 'cds.Decimal', // Precision, scale
    //'Edm.DateTime_f': 'cds.Date', // sap:display-format="Date"
    //'Edm.DateTimeOffset_f': 'cds.Date', // sap:display-format="Date"
    'Edm.Binary_m': 'cds.Binary', // Max Length
    'Edm.Byte_m': 'cds.Integer', // Max Length
    'Edm.Double_p': 'cds.Double', // Precision, scale
    // Special handling with annotations
	"Edm.Single_a": "cds.Double",
	"Edm.Stream_a" : "cds.LargeBinary",
	"Edm.DateTimeOffset_a" : "cds.Timestamp"
};

function _initialize() {
    unboundedActions = {};
    boundedActions = {};
    unboundedFunctions = {};
    boundedFunctions = {};
    entityTypes = [];
    namespace = "";
    complexTypes = {};
    enumTypes = {};
    typeDefinitions = {};
    jsonEntityContainerName = "";

}

function _isJson(edmx) {
    let isJson = false;
    try {
        JSON.parse(edmx);
        isJson = true;
    } catch (err) {
        isJson = false;
    }
    return isJson;
}

function _isValidDataType(propertyType) {
    if (validEdmDatatypes.includes(propertyType)) {
        return true;
    }
    return false;
}

function _isValidJSON(jsonObj) {
    let tempNamespace = jsonObj.$EntityContainer;
    namespace = tempNamespace.substring(0, tempNamespace.lastIndexOf('.'));
    jsonEntityContainerName = tempNamespace.substring(tempNamespace.lastIndexOf('.') + 1);

    if (jsonObj.$Version && jsonObj.$EntityContainer && jsonObj[namespace]) {
        return true;
    }
    else {
        throw new Error(messages.INVALID_EDMX_METADATA);
    }
}

function _hasEntityContainer(jsonObj) {
    if (jsonObj[namespace][jsonEntityContainerName] && jsonObj[namespace][jsonEntityContainerName] instanceof Object) {
        return true;
    } else {
        throw new Error(messages.MISSING_ENTITY_CONTAINER);
    }
}

function _hasEntitySet(jsonObj) {
    let entitySetCount = 0;
    let entityContainerData = jsonObj[namespace][jsonEntityContainerName];
    Object.keys(entityContainerData).forEach(data => {
        if (ignoreObjects.indexOf(data) === -1 && entityContainerData[data] instanceof Object) {
            if (entityContainerData[data].$Collection === true) {
                entitySetCount += 1;
            }
        }
    });

    if (entitySetCount == 0) {
        throw new Error(messages.MISSING_ENTITY_SETS);
    }
    return true;
}

function _validateJSON(jsonObj) {
    return (
        _isValidJSON(jsonObj) &&
        _hasEntityContainer(jsonObj) &&
        _hasEntitySet(jsonObj)
    );
}

function _includeExternalNamespaceAnnotation(source,target){
    Object.entries(source).forEach(element => {
        if (element[0].startsWith('@')) {
            target[element[0]] = element[1];
        }
    });
}

function _typeWithCollections(property, type, isCollection) {
  if (isCollection === true) {
    property.items = type;
  } else {
    Object.assign(property, type);
  }
}

function generatePropertyCsn(propertyType, isPrimaryKey) {
    let property = {};
    let typeProperties = {};
    if (isPrimaryKey) {
        property.key = true;
        // primary key cannot be of type Collection
        if (propertyType.$Collection)
            throw new Error(messages.COLLECTION_IN_KEY);
    }
    _includeExternalNamespaceAnnotation(propertyType,property);
    // conditions have to be made
    if (propertyType.$MaxLength) {
        if (propertyType.$Type) {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_m'];
        } else {
            typeProperties.type = 'cds.String'; // if type is missing, then it is String type
        }
        typeProperties.length = propertyType.$MaxLength;
    } else if(_isValidDataType(propertyType.$Type)) {
        if(propertyType.$Precision && propertyType.$Precision > 0)
        {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_a'];
            typeProperties["@odata.precision"] = propertyType.$Precision;
        } else {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type];
            typeProperties["@odata.precision"] = 0;
        }
    } else if (propertyType.$Precision && !_isValidDataType(propertyType.$Type)) {
        typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_p'];
        typeProperties.precision = propertyType.$Precision;
        if (propertyType.$Scale && propertyType.$Scale == 'variable') {
            typeProperties.scale = propertyType.$Precision;
            typeProperties.precision = propertyType.$Precision * 2;
        } else {
            typeProperties.scale = propertyType.$Scale;
        }
    } else if (edmxncdsdatatype[propertyType.$Type + "_a"]) {
        typeProperties.type = edmxncdsdatatype[propertyType.$Type + "_a"];
    } else if (propertyType.$Type) {
        typeProperties.type = edmxncdsdatatype[propertyType.$Type];
    } else{
        typeProperties.type = 'cds.LargeString'; // if type is missing, then it is String type
    }

    if (edmxncdsdatatype[propertyType.$Type + '_a']) {
        typeProperties["@odata.type"] = propertyType.$Type;
    }

    _typeWithCollections(property, typeProperties, propertyType.$Collection);

    return property;
}

function _generateComplexTypePropertyCsn(propertyType) {
    let property = {};
    let type = {type : propertyType.$Type}
    _typeWithCollections(property, type, propertyType.$Collection);
    
    return property;
}

function _generateTypeDefinitionPropertyCsn(propertyType) {
    let property = {};
    let type = {type : propertyType.$Type}
    
    _includeExternalNamespaceAnnotation(propertyType,property);
    _typeWithCollections(property, type, propertyType.$Collection);

    return property;
}

function _parseAssociationProperty(foreignReference, associationNode, mockServerUc) {
    let associationProperty = {};
    let foreignKeys;
    // var foreignReference = associationNode.$Type;
    let refConstraint = associationNode.$ReferentialConstraint;
    let i;
    let data;
    let ref;
    associationProperty.type = 'cds.Association';
    // annotation for ON condition
    associationProperty["@cds.ambiguous"] = 'missing on condition?';
    // associationProperty.target = associationNode.$Type;
    if (mockServerUc && entitySetToEntityTypeMap && entitySetToEntityTypeMap.get(associationNode.$Type)) {
        if (entitySetToEntityTypeMap.get(associationNode.$Type).length > 1) {
            for (let j = 0; j < entitySetToEntityTypeMap.get(associationNode.$Type).length; j++) {
                if (entitySetToEntityTypeMap.get(associationNode.$Type)[j] === foreignReference) {
                    associationProperty.target = namespace + '.' +
                        entitySetToEntityTypeMap.get(associationNode.$Type)[j];
                }
            }
        } else {
            associationProperty.target = namespace + '.' + entitySetToEntityTypeMap.get(associationNode.$Type);
        }
    } else {
        associationProperty.target = associationNode.$Type;
    }
    // cardinality
    associationProperty.cardinality = {};
    if (associationNode.$Collection) {
        associationProperty.cardinality.max = '*';
    } else {
        associationProperty.cardinality.max = 1;
    }
    // on -> "SalesOrders.CustomerID=CustomerID and SalesOrders.Type=Type"
    if (refConstraint) {
        associationProperty.on = [];
        foreignKeys = Object.keys(refConstraint);
        for (i = 0; i < foreignKeys.length; i++) {
            data = {};
            ref = [];
            ref.push(foreignReference);
            ref.push(refConstraint[foreignKeys[i]]);
            data.ref = ref;
            associationProperty.on.push(data);
            associationProperty.on.push('=');
            data = {};
            ref = [];
            ref.push(foreignKeys[i]);
            data.ref = ref;
            associationProperty.on.push(data);
            if (i < foreignKeys.length - 1) {
                associationProperty.on.push(' and ');
            }
        }
    }
	// Convert managed associations and compositions in unmanaged with empty key to avoid
    // "generation" of keys, that do not exist in the external service.
    if (common.checkForEmptyKeys(associationProperty, "V4")) {
        associationProperty.keys = [];
    }
    _includeExternalNamespaceAnnotation(associationNode,associationProperty);
    return associationProperty;
}

function _getBaseTypeEntityName(baseType) {
    const mappedResult = entitySetToEntityTypeMap.get(baseType);
    // if one entity type has mapping to multiple entity sets, use the first entity set
    if (mappedResult.length > 1) {
        return namespace + '.' + mappedResult[0];
    } else {
        return namespace + '.' + mappedResult;
    }
}

function _generateCSNForEntityType(ignorePersistenceSkip, mockServerUc) {
    let entityCsn = {};
    let keySet;
    let curKey;
    let j;
    let propertyType;
    let enumType = {};
    entityTypes.forEach(element => {
        let key = Object.keys(element)[0];
        let baseType = element[key].$BaseType;
        let isAbstract = element[key].$Abstract;
        if (key) {
            entityCsn[key] = {};
            entityCsn[key].kind = 'entity';
            if (!ignorePersistenceSkip) {	
                entityCsn[key]['@cds.persistence.skip'] = true;	
            }
            _includeExternalNamespaceAnnotation(element[key],entityCsn[key]);
            // inheritance
            if (baseType) {
                entityCsn[key].includes = [];
                // if the baseType has a mapping to an entity set use that
                if (entitySetToEntityTypeMap && entitySetToEntityTypeMap.get(baseType)) {
                    baseType = _getBaseTypeEntityName(baseType);
                }
                entityCsn[key].includes.push(baseType);
            }
            if (isAbstract) {
                entityCsn[key].abstract = isAbstract;
            }
            entityCsn[key].elements = {};
            keySet = [];
            Object.keys(element[key]).forEach(property => {
                // Annotations names can have either @ or .; Don't add in generated CSN as property.
                // CDS compiler will throw error when property name has special characters
                if ((property.indexOf('@') == -1) && (property.indexOf('.') == -1)) {
                    if (element[key][property] instanceof Object) {
                        if (property === '$Key') {
                            curKey = element[key].$Key;
                            for (j = 0; j < curKey.length; j++) {
                                keySet.push(curKey[j]);
                            }
                        } else if (!element[key][property].$Type || edmxncdsdatatype[element[key][property].$Type] || edmxncdsdatatype[element[key][property].$Type + "_a"]) {
                            propertyType = element[key][property];
                            if (keySet.includes(property)) {
                                entityCsn[key].elements[property] = generatePropertyCsn(propertyType, true);
                            } else {
                                entityCsn[key].elements[property] = generatePropertyCsn(propertyType, false);
                            }
                        } else if (!element[key][property].$Type || enumTypes[element[key][property].$Type]) {
                            enumType.$Type = enumTypes[element[key][property].$Type].$UnderlyingType;
                            if (keySet.includes(property)) {
                                entityCsn[key].elements[property] = generatePropertyCsn(enumType, true);
                            } else {
                                entityCsn[key].elements[property] = generatePropertyCsn(enumType, false);
                            }
                        } else if (complexTypes[element[key][property].$Type]) {
                            propertyType = element[key][property];
                            entityCsn[key].elements[property] = _generateComplexTypePropertyCsn(propertyType);
                        } else if (element[key][property].$Kind === 'NavigationProperty') {
                            entityCsn[key].elements[property] = _parseAssociationProperty(property,
                                element[key][property], mockServerUc);
                        } else if (typeDefinitions[element[key][property].$Type]){
                            // for TypeDefinitions
                            propertyType = element[key][property];
                            entityCsn[key].elements[property] = _generateTypeDefinitionPropertyCsn(propertyType);
                        } else {
                            let message = '"' + element[key][property].$Type + '" is not supported (in element:"' + property + '")'; 
                            console.log(warn(message));
                        }
                    }
                }
            });
        }
    });
    return entityCsn;
}

function _generateEntityType(schemaData, mockServerUc) {
    let entity = {};
    let temp;
    Object.keys(schemaData).forEach(entityType => {
        entity = {};
        if (schemaData[entityType] instanceof Object) {
            if (schemaData[entityType].$Kind && schemaData[entityType].$Kind === 'EntityType') {
                if (mockServerUc) {
                    let entityTypeName = namespace + '.' + entityType;
                    if (entitySetToEntityTypeMap && entitySetToEntityTypeMap.get(entityTypeName)) {
                        if (entitySetToEntityTypeMap.get(entityTypeName).length > 1) {
                            let entity1 = {};
                            for (let i = 0; i < entitySetToEntityTypeMap.get(entityTypeName).length; i++) {
                                entity1 = {};
                                let temp1 = namespace + '.' + entitySetToEntityTypeMap.get(entityTypeName)[i];
                                entity1[temp1] = schemaData[entityType];
                                entityTypes.push(entity1);
                            }
                        } else {
                            temp = namespace + '.' + entitySetToEntityTypeMap.get(entityTypeName);
                            entity[temp] = schemaData[entityType];
                            entityTypes.push(entity);
                        }
                    } else {
                        temp = namespace + '.' + entityType;
                        entity[temp] = schemaData[entityType];
                        entityTypes.push(entity);
                    }
                } else {
                    temp = namespace + '.' + entityType;
                    entity[temp] = schemaData[entityType];
                    entityTypes.push(entity);
                }
            }
        }
    });
}

function _parseEntityType(schemaDataList, ignorePersistenceSkip, mockServerUc) {
    // collect entity types
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        _generateEntityType(schemaData, mockServerUc);
    }
    return _generateCSNForEntityType(ignorePersistenceSkip, mockServerUc);
}
function _parseEntityContainer(entityCSN, schemaData){
    Object.entries(schemaData[0][jsonEntityContainerName]).forEach(entry => {
        if(entityCSN[namespace + '.' + entry[0]])
            //Captured the annotations at entity set and entity type name level
            _includeExternalNamespaceAnnotation(entry[1],entityCSN[namespace + '.' + entry[0]]);
        if(entry[0].startsWith('@')){
            //Captured the annotations at entity container name level
            entityCSN[namespace][entry[0]]= entry[1];
        }
    });
    return entityCSN;
}
function _generateEnumType(schemaData) {
    let enumTypeDict = {};
    let temp;
    Object.keys(schemaData).forEach(curEnumType => {
        if (schemaData[curEnumType] instanceof Object) {
            if (schemaData[curEnumType].$Kind && schemaData[curEnumType].$Kind === 'EnumType') {
                temp = namespace + '.' + curEnumType;
                enumTypeDict[temp] = schemaData[curEnumType];
            }
        }
    });
    return enumTypeDict;
}

function _collectEnumType(schemaDataList) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        enumTypes = _generateEnumType(schemaData);
    }
    return enumTypes;
}

function _generateTypeDefinition(schemaData) {
    let typeDefDict = {};
    let temp;
    Object.keys(schemaData).forEach(curTypeDef => {
        if (schemaData[curTypeDef] instanceof Object) {
            if (schemaData[curTypeDef].$Kind && schemaData[curTypeDef].$Kind === 'TypeDefinition') {
                temp = namespace + '.' + curTypeDef;
                typeDefDict[temp] = schemaData[curTypeDef];
            }
        }
    });
    return typeDefDict;
}

function _collectTypeDefinition(schemaDataList) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        typeDefinitions = _generateTypeDefinition(schemaData);
    }
}

function _generateBounded(schemaData, flag) {
    let bFunction = {};
    let boundedFunction = [];
    let temp;
    let kindString;
    if (flag == 1) {
        kindString = 'Function'; 
    }
    else {
        kindString = 'Action';
    }
    Object.keys(schemaData).forEach(curFunction => {
        if (schemaData[curFunction] instanceof Array && schemaData[curFunction][0].$Kind === kindString && schemaData[curFunction][0].$IsBound === true) {
            boundedFunction = [];
            temp = namespace + '.' + curFunction;
            for (let i = 0; i < schemaData[curFunction].length; i++) {
                boundedFunction.push(schemaData[curFunction][i]);
                bFunction[temp] = boundedFunction;
            }
        }
    });
    return bFunction;
}

function _collectBounded(schemaDataList, flag) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        if (flag == 0) {
            boundedActions = _generateBounded(schemaData, 0);
        }
        else {
            boundedFunctions = _generateBounded(schemaData, 1);
        }    
    }
}

function _getDatatype(datatype) {
    let type = undefined;
    if (datatype === undefined) {
        type = "cds.LargeString"; //intentionally used LargeString
    } else if (entitySetToEntityTypeMap.get(datatype) && entitySetToEntityTypeMap.get(datatype)[0]) {
        //mapping to entity set if type is entity type
        type = namespace + "." + entitySetToEntityTypeMap.get(datatype)[0];
    } else if (complexTypes[datatype] || typeDefinitions[datatype] || enumTypes[datatype]) {
        //if type is complex type, type definition or an enum type
        type = datatype;
    } else {
        //checking if type is an entity set
        for (const element of entitySetToEntityTypeMap.keys()) {
            if (namespace + "." + entitySetToEntityTypeMap.get(element) === datatype)
                type = datatype;
        }
        entityTypes.forEach(entity =>{
            if(entity[datatype])
                type = datatype;
        })
    }

    //will return undefined if type is not supported
    return type;
}

function _parseBounded(csnDefs, flag) {
    let boundedEdmxKind, boundedObj, boundedCsnKind, boundedEntityName, obj, paramName, paramObj, name;
    if (flag == 0) {
        boundedEdmxKind = "Action";
        boundedCsnKind = "action";
        boundedObj = boundedActions;
    }
    else {
        boundedEdmxKind = "Function";
        boundedCsnKind = "function";
        boundedObj = boundedFunctions;
    }
    if (Object.keys(boundedObj).length > 0) {
        Object.keys(boundedObj).forEach(b => {
            for (let j = 0; j < boundedObj[b].length; j++) {
                if (boundedObj[b][j].$Kind === boundedEdmxKind) {
                    name = b.substring(b.lastIndexOf(".") + 1);
                    obj = boundedObj[b];
                    boundedEntityName = obj[j].$Parameter[0].$Type;
                    if (csnDefs[boundedEntityName] === undefined) {
                        boundedEntityName = namespace + "." + entitySetToEntityTypeMap.get(boundedEntityName)[0];
                    }
                    if (csnDefs[boundedEntityName]) {
                        if (csnDefs[boundedEntityName].actions === undefined)
                            csnDefs[boundedEntityName].actions = {};
                        csnDefs[boundedEntityName].actions[name] = {};
                        _includeExternalNamespaceAnnotation(obj[0],csnDefs[boundedEntityName].actions[name]);
                        csnDefs[boundedEntityName].actions[name].kind = boundedCsnKind;
                        // add params
                        if (obj[j].$Parameter && obj[j].$Parameter.length >= 2) {
                            /** 
                             * 1. Considering length >= 2 because we need to consider from the 2nd
                             *    parameter onwards. 1st parameter only tells which entity is this
                             *    action/function bounded to and that parameter is no where used 
                             *    to retrieve any data during service runtime. So skipping it and
                             *    the details of 1st parameter will not be preserved in the csn.
                             * 2. The 1st parameter will be reflected back as parameter name  "in" 
                             *    during csn to edmx conversion by the compiler.
                             * */
                            csnDefs[boundedEntityName].actions[name].params = {};
                            for (let i = 1; i < obj[j].$Parameter.length; i++) {
                                paramObj = obj[j].$Parameter[i];
                                paramName = obj[j].$Parameter[i].$Name;
                                let paramType = {};
                                let annotations = {};
                                _includeExternalNamespaceAnnotation(paramObj,annotations);
                                //check if the parameter type is pre-defined, undefined or custom defined
                                if (edmxncdsdatatype[paramObj.$Type] || edmxncdsdatatype[paramObj.$Type + "_a"])
                                    paramType = generatePropertyCsn(paramObj, false);
                                else {
                                    let type = _getDatatype(paramObj.$Type);
                                    if(type) paramType["type"] = type;
                                }
                                if(Object.keys(paramType).length > 0) 
                                {
                                    if (paramType.type || paramType.items.type) {
                                        // check if parameter type is a collection
                                        if (paramObj.$Collection && !paramType.items) {
                                            csnDefs[boundedEntityName].actions[name].params[paramName] = {};
                                            csnDefs[boundedEntityName].actions[name].params[paramName].items = paramType;
                                        } else
                                            csnDefs[boundedEntityName].actions[name].params[paramName] = paramType;
                                    } 
                                }
                                else {
                                    let message = '"' + paramObj.$Type + '" is not supported (in element:"' + name + '")'; 
                                    console.log(warn(message));
                                }
                                if(csnDefs[boundedEntityName].actions[name].params[paramName])
                                    Object.assign(csnDefs[boundedEntityName].actions[name].params[paramName], annotations);
                            }                             
                        }
                    }
                    //if parameters has no entries
                    if (csnDefs[boundedEntityName].actions[name].params && Object.keys(csnDefs[boundedEntityName].actions[name].params).length === 0) {
                        delete csnDefs[boundedEntityName].actions[name].params;
                    }
                    // add returns
                    if (obj[j].$ReturnType) {
                        let returnType = {};
                        let annotations = {};
                        // check if the return type is pre-defined, undefined or custom defined
                        if (edmxncdsdatatype[obj[j].$ReturnType.$Type] || edmxncdsdatatype[obj[j].$ReturnType.$Type + "_a"])
                            returnType = generatePropertyCsn(obj[j].$ReturnType, false);
                        else {
                            let type = _getDatatype(obj[j].$ReturnType.$Type);
                            _includeExternalNamespaceAnnotation(obj[j].$ReturnType,annotations);
                            if(type) returnType["type"] = type ;
                        }
                        if(Object.keys(returnType).length > 0){
                            if (returnType.type || returnType.items.type) {
                                csnDefs[boundedEntityName].actions[name].returns = {};
                                // check if return type is a collection
                                if (obj[j].$ReturnType.$Collection && !returnType.items)
                                    csnDefs[boundedEntityName].actions[name].returns.items = returnType;
                                else
                                    csnDefs[boundedEntityName].actions[name].returns = returnType;
                            } 
                        }   else {
                            let message = '"' + obj[j].$ReturnType.$Type + '" is not supported (in return type)'; 
                            console.log(warn(message));
                        }
                        if(csnDefs[boundedEntityName].actions[name].returns)
                            Object.assign(csnDefs[boundedEntityName].actions[name].returns, annotations)
                    }
                }
            }
        });
    }
}

function _generateComplexType(schemaData) {
    let complexTypeDict = {};
    let temp;
    Object.keys(schemaData).forEach(curComplexType => {
        if (schemaData[curComplexType] instanceof Object) {
            if (schemaData[curComplexType].$Kind && schemaData[curComplexType].$Kind === 'ComplexType') {
                temp = namespace + '.' + curComplexType;
                complexTypeDict[temp] = schemaData[curComplexType];
            }
        }
    });
    return complexTypeDict;
}

function _collectComplexType(schemaDataList) {
    // collect complex types
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        complexTypes = _generateComplexType(schemaData);
    }
    return complexTypes;
}

function _generateCSNForComplexType(schemaData) {
    let complexCsn = {};
    let cTypes;
    let propertyType;
    let baseType;
    cTypes = _collectComplexType(schemaData);
    Object.keys(cTypes).forEach(element => {
        complexCsn[element] = {};
        complexCsn[element].kind = 'type';
        complexCsn[element].elements = {};
        // inheritance handling
        baseType = cTypes[element].$BaseType;
        if (baseType) {
            complexCsn[element].includes = [];
            complexCsn[element].includes.push(baseType);
        }
        Object.keys(cTypes[element]).forEach(property => { // cTypes[element][property].$Type.startsWith('Edm.')
            if (cTypes[element][property] instanceof Object) {
                if (!cTypes[element][property].$Type || edmxncdsdatatype[cTypes[element][property].$Type] || edmxncdsdatatype[cTypes[element][property].$Type + "_a"]) {
                    propertyType = cTypes[element][property];
                    complexCsn[element].elements[property] = generatePropertyCsn(propertyType, false);
                } else if (complexTypes[cTypes[element][property].$Type]) {
                    propertyType = cTypes[element][property];
                    complexCsn[element].elements[property] = _generateComplexTypePropertyCsn(propertyType);
                } else {
                    let message = '"' + cTypes[element][property].$Type + '" is not supported (in element:"' + property + '")';
                    console.log(warn(message));
                }
            } else if (property.startsWith("@")) {
                complexCsn[element][property] = cTypes[element][property];
            }
        });
    });
    return complexCsn;
}

function _parseTypeDefinition() {
    let typeDef = {};
    let propertyType;
    Object.keys(typeDefinitions).forEach(element => {
        typeDef[element] = {};
        typeDef[element].kind = 'type';
        if (!typeDefinitions[element].$Type || edmxncdsdatatype[typeDefinitions[element].$Type]) {
            propertyType = typeDefinitions[element];
            typeDef[element] = Object.assign(typeDef[element], generatePropertyCsn(propertyType, false));
        }
    });
    return typeDef;
}

function _parseUnbounded(schemaData, flag) {
    let unboundedObj = {}, unbounded, unboundedCsnKind;
    let importToMap = new Multimap();
    if (flag == 0) {
        unbounded = unboundedActions;
        importToMap = actionImportToActionMap;
        unboundedCsnKind = "action";
    }
    else {
        unbounded = unboundedFunctions;
        importToMap = functionImportToFunctionMap;
        unboundedCsnKind = "function";
    }
    if (Object.keys(unbounded).length > 0) {
        Object.keys(unbounded).forEach(ub => {
            let obj = {};
            let objType = {}, objData = {}, temp = {};
            if (importToMap && importToMap.get(ub)) { 
                temp = ub.split(".").pop();
                objType = namespace + "." + temp;
                objData = schemaData[0][temp][0];
                obj[objType] = {};
                obj[objType].kind = unboundedCsnKind;
                _includeExternalNamespaceAnnotation(objData,obj[objType]);
                // add params
                if (objData.$Parameter && objData.$Parameter.length > 0) {
                    obj[objType].params = {};   
                    for (let i = 0; i < objData.$Parameter.length; i++) {
                        let paramType = {};
                        let annotations = {};
                        _includeExternalNamespaceAnnotation(objData.$Parameter[i], annotations);
                        // check if the parameter type is pre-defined, undefined or custom defined
                        if (edmxncdsdatatype[objData.$Parameter[i].$Type] || edmxncdsdatatype[objData.$Parameter[i].$Type + "_a"]) {
                            paramType = generatePropertyCsn(objData.$Parameter[i],false)
                        } else {
                            let type = _getDatatype(objData.$Parameter[i].$Type);
                            if(type) paramType["type"] = type;
                        }
                        if(Object.keys(paramType).length > 0){
                            if (paramType.type || paramType.items.type) {
                                // check if parameter type is a collection
                                if (objData.$Parameter[i].$Collection && !paramType.items) {
                                    obj[objType].params[objData.$Parameter[i].$Name] = {};
                                    obj[objType].params[objData.$Parameter[i].$Name].items = paramType;
                                } else
                                    obj[objType].params[objData.$Parameter[i].$Name] = paramType;
                            } 
                        }else {
                            let message = '"' + objData.$Parameter[i].$Type + '" is not supported (in element:"' + temp + '")'; 
                            console.log(warn(message));
                        }
                        if(obj[objType].params[objData.$Parameter[i].$Name])
                            Object.assign(obj[objType].params[objData.$Parameter[i].$Name], annotations)
                    }
                }
                //if parameters has no entries
                if (obj[objType].params && Object.keys(obj[objType].params).length === 0) {
                    delete obj[objType].params;
                }
                // add returns
                if (objData.$ReturnType && Object.keys(objData.$ReturnType).length > 0 && obj) {
                    let returnValue = {};
                    let annotations = {};
                    // check if the return type is pre-defined, undefined or custom defined
                    if (edmxncdsdatatype[objData.$ReturnType.$Type] || edmxncdsdatatype[objData.$ReturnType.$Type + "_a"]) {
                        returnValue = generatePropertyCsn(objData.$ReturnType, false);
                    } else {
                        let type = _getDatatype(objData.$ReturnType.$Type);
                        _includeExternalNamespaceAnnotation(objData.$ReturnType,annotations);
                        if(type) returnValue["type"] = type;
                    }
                    if(Object.keys(returnValue).length > 0){
                        if (returnValue.type || returnValue.items.type) {
                            obj[objType].returns = {};
                            // check if return type is a collection
                            if (objData.$ReturnType.$Collection && !returnValue.items) {
                                obj[objType].returns.items = {};
                                obj[objType].returns.items = returnValue;
                            } else
                                obj[objType].returns = returnValue;
                        }
                    } 
                    else {
                        let message = '"' + objData.$ReturnType.$Type + '" is not supported (in return type of' + temp + ')'; 
                        console.log(warn(message));
                    }
                    if(obj[objType].returns)
                        Object.assign(obj[objType].returns, annotations);
                }
            }
            unboundedObj = Object.assign(unboundedObj, obj);
        });
    }
    return unboundedObj;
}

function _generateCSN(edmxAsJson, ignorePersistenceSkip, mockServerUc) {
    let csn = {};
    let schemaData = [];
    csn.meta = {};
    csn.meta.creator = 'cds-dk ' + versionInfo;
    csn.$version = '2.0';
    csn.definitions = {};

    Object.keys(edmxAsJson).forEach(data => {
        if (ignoreObjects.indexOf(data) === -1 && edmxAsJson[data] instanceof Object) {
            // replace the namespace alias value with original namespace value
            if (edmxAsJson[data].$Alias)
                edmxAsJson[data] = common.replaceAliasValue(JSON.stringify(edmxAsJson[data]), data, edmxAsJson[data].$Alias);
            schemaData.push(edmxAsJson[data]);
        }
    });

    if (mockServerUc) {
        let entitySetData = edmxAsJson[namespace];
        let entityContainer;
        Object.keys(entitySetData).forEach(data => {
            if (ignoreObjects.indexOf(data) === -1 && entitySetData[data] instanceof Object) {
                if (entitySetData[data].$Kind && entitySetData[data].$Kind === 'EntityContainer') {
                    entityContainer = entitySetData[data];
                }
            }
        });
        Object.keys(entityContainer).forEach(data => {
            if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Type && entityContainer[data].$Collection) {
                entitySetToEntityTypeMap.set(entityContainer[data].$Type, data);
            } else if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Action) {
                actionImportToActionMap.set(entityContainer[data].$Action, data);
                unboundedActions[entityContainer[data].$Action] = entitySetData[data];
            } else if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Function) {
                functionImportToFunctionMap.set(entityContainer[data].$Function, data);
                unboundedFunctions[entityContainer[data].$Function] = entitySetData[data];
            }
        });
    }

    csn.definitions[namespace] = {};
    csn.definitions[namespace].kind = 'service';
    csn.definitions[namespace]['@cds.external'] = true;

    _collectEnumType(schemaData);
    _collectTypeDefinition(schemaData);
    _collectBounded(schemaData, 0);
    _collectBounded(schemaData, 1);

    // Step 1: get all complex types.
    csn.definitions = Object.assign(_generateCSNForComplexType(schemaData), csn.definitions);
    // Step 2: get all type definition
    csn.definitions = Object.assign(_parseTypeDefinition(), csn.definitions); 
    // Step 3: get all entity type
    csn.definitions = Object.assign(_parseEntityType(schemaData, ignorePersistenceSkip, mockServerUc), csn.definitions);
    // Step 4: get all unbounded action & function
    csn.definitions = Object.assign(_parseUnbounded(schemaData, 0), csn.definitions);
    csn.definitions = Object.assign(_parseUnbounded(schemaData , 1), csn.definitions);
    // Step 5: add entity container properties
    csn.definitions = Object.assign(_parseEntityContainer(csn.definitions,schemaData),csn.definitions);
    // Step 6: get all bounded action & function
    _parseBounded(csn.definitions, 0);
    _parseBounded(csn.definitions, 1);
    // Step 7: get all annotations
    _generateDocumentation(schemaData, csn.definitions);

    return JSON.stringify(csn, null, 4);
}

function _replaceSpecialCharacters(text) {
    return text.replace(/(?:\\[rn]|[\r\n]+)+/gm, "\n").replace(/\s+/g, ' ').replace(/"/g, "&quot;").trim();
}

function _checkAnnotatationTerm(annotation, path, no_of_terms, targetString){
   if(path){
        if(targetString === "@Core.Description" && annotation[1]["@Core.Description"]){
            if(path.doc === undefined)
                path.doc = _replaceSpecialCharacters(annotation[1]["@Core.Description"]);
            else
                path.doc += _replaceSpecialCharacters(annotation[1]["@Core.Description"]);
        }
        else if(targetString === "@Core.LongDescription" && annotation[1]["@Core.LongDescription"]){
            _generateLongDescription(annotation,path,no_of_terms);
        }
    }
}
function _checkAnnotationTarget(annotation, cdsDefs , str, no_of_terms){
    if (annotation[0].indexOf('/') === -1 && annotation[0].indexOf('(') === -1) {
        if (annotation[0].endsWith(".EntityContainer")) {
            let path = annotation[0].split(".")[0];
            
            _checkAnnotatationTerm(annotation,cdsDefs[path],no_of_terms,str);  
        }
        if (cdsDefs[annotation[0]]) {
            _checkAnnotatationTerm(annotation, cdsDefs[annotation[0]], no_of_terms , str);
        }
    } else if(annotation[0].indexOf('(') === -1 && !(annotation[0].indexOf('/') === -1)){
        let path = annotation[0].split('/');
        if(cdsDefs[path[0]]){
             _checkAnnotatationTerm(annotation, cdsDefs[path[0]]["elements"][path[1]], no_of_terms, str);
        }   
    } else{
        let path = annotation[0].split('(');
        if(cdsDefs[path[0]]== undefined){
            let temp = path[1].split(')');
            let path1 = temp[0].split(',');
            let path2 = path[0].split('.');
            if(cdsDefs[path1[0]]){
                _checkAnnotatationTerm(annotation,cdsDefs[path1[0]]["actions"][path2[1]],no_of_terms,str);
            }
        } else{
            if(path[1].indexOf('/') === -1){ 
            _checkAnnotatationTerm(annotation,cdsDefs[path[0]],no_of_terms,str);   
            } else{
                let path1 = path[1].split('/');
                if(cdsDefs[path[0]] && cdsDefs[path[0]]["params"]){
                    _checkAnnotatationTerm(annotation,cdsDefs[path[0]]["params"][path1[1]],no_of_terms,str);
                }
            }    
        }
    }
}

function _generateDocumentation(schemaData, cdsDefs) {
    if (schemaData[0].$Annotations) {
        Object.entries(schemaData[0].$Annotations).map(annotation => {
            let no_of_terms;
            // eslint-disable-next-line no-prototype-builtins
            if (annotation[1].hasOwnProperty('@Core.Description')) {

                no_of_terms = true;
                _checkAnnotationTarget(annotation,cdsDefs,"@Core.Description",no_of_terms);
            }
            // eslint-disable-next-line no-prototype-builtins
            if (annotation[1].hasOwnProperty('@Core.LongDescription')) {
                _checkAnnotationTarget(annotation,cdsDefs,"@Core.LongDescription",no_of_terms);

                            }
        });
    }
}

function _generateLongDescription(annotation,path,no_of_terms){
    if(path){
        path.doc = no_of_terms ? (path.doc += "\n\n") : (path.doc ? (path.doc+="") : (path.doc=""));
        path.doc += _replaceSpecialCharacters(annotation[1]["@Core.LongDescription"]);
        return(path.doc);
    }
}


function _generateEDMX2JSON(edmx, name_space) { 
    return new Promise(function getJson(resolve, reject) { 
        try { 
            const inputBuffer = edmx;
            // create converter
            const v4Conv = MetadataConverterFactory.createEdmxV40XmlToV40Json(name_space);
            v4Conv.execute(inputBuffer, (error, json, missingReferencedDocuments) => { 
                if (missingReferencedDocuments.length > 0) {
                    console.log(missingReferencedDocuments); // eslint-disable-line no-console
                }
                if (_validateJSON(json)) {
                    resolve(json);
                }
            });
        } catch (err) { 
            reject(err);
        }
    });
}

function getEdmxv4CSN(edmx, ignorePersistenceSkip, mockServerUc, context) {
    let csn;
    let edmjConverted;
    let name_space = []
    _initialize();
    if(context.include_all_namespaces === true)
    {
        name_space.push(true);
    }
    else{
        name_space = context.namespaces;
    }
    if (_isJson(edmx)) {
        return new Promise(function getCsn(resolve, reject) {
            try {
                edmjConverted = JSON.parse(edmx);
                if (_validateJSON(edmjConverted)) {
                    csn = _generateCSN(edmjConverted, ignorePersistenceSkip, mockServerUc);
                    if (csn) {
                        resolve(csn);
                    } else {
                        reject(errors);
                    }
                }
            } catch (err) {
                reject(err);
            }
        });
    }
    return _generateEDMX2JSON(edmx,name_space).then(function getCsn(edmj) {
        // now parsing logic
        return _generateCSN(edmj, ignorePersistenceSkip, mockServerUc);
    });
}

module.exports = {
    getEdmxv4CSN
};
