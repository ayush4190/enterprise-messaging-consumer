
"use strict";
let convert = require('xml-js');
let axios = require('axios');
let edmxv2CSN = require("./v2parser");
let edmxv4CSN = require("./v4parser");
const messages = require("./message").getMessages();
let common = require("./common");
const cds = require('@sap/cds');
const fs = cds.utils, { path } = fs;
let defaultFileName;

async function _isValidXML(text) {
	let isValid = false;
	let cjson;
	try {
		cjson = convert.xml2json(text, {
			compact: true,
			spaces: 4
		});
		JSON.parse(cjson);
		isValid = true;
	} catch (err) {
		isValid = false;
	}
	return isValid;
}

async function isValidInputFile(inputFileLoc) {
	let file;
	const fileResolved = await fs.isfile(inputFileLoc);

	if (!fileResolved) {
		throw new Error(messages.SPECIFY_INPUT_FILE);
	}
	else if (inputFileLoc.endsWith(".edmx") || inputFileLoc.endsWith(".xml")) {
		file = fileResolved;
		defaultFileName = file;
	} else {
		throw new Error(messages.INVALID_INPUT_FILE);
	}
	return file;
}

function validateAndComputeOutputFilePath(outputFileLoc, as) {
	let index, extension, expectedExtension, supportedExtension;
	if (typeof(outputFileLoc) !== 'boolean') {
		index = outputFileLoc.lastIndexOf(".");
		extension = outputFileLoc.substring(index + 1);
		expectedExtension = (as) ? common.getSuffix(as) : "csn";
		supportedExtension = (index > 0) ? common.supportedFormats().includes(extension) : false;
	}

	if (outputFileLoc === true || // if output file is not mentioned
		outputFileLoc[0] === "-" || // if output file is missing and "--as" is considered as output file
		outputFileLoc.trim() === "") {
		throw new Error(messages.SPECIFY_OUTPUT_FILE);
	} else if (index > 0 && !supportedExtension) { 
		// extension not supported, eg., "test.abs", "./sv/external.test.abcs", "./a."
		throw new Error(messages.INVALID_OUTPUT_FILE);
	} else if (index > 0 && !as && extension != "json" && extension != "csn") {
		// --as option is not provided but output file is like: "test.cds", "./srv/external/test.cds"
		throw new Error(messages.INCORRECT_EXTENSION);
	} else if (index > 0 && as && extension != expectedExtension){ 
		// extension not supported by --as option, e.g., "cds import <file> --out test.yml --as cds"
		throw new Error(messages.OUTPUT_FILE_MISMATCH);
	} else if (supportedExtension || (!outputFileLoc.endsWith("\\") && !outputFileLoc.endsWith("/"))) {
		// eg., "./a.csn", "tst.cds", "./srv/external/test", "test", "c:\windows\output\test"
		return outputFileLoc;
	} else if (outputFileLoc.endsWith("/") || outputFileLoc.endsWith("\\")){ 
		// File name not specified ("./srv/external/", "c:\windows\output\test\") 
		return outputFileLoc + path.parse(defaultFileName).name;
	}
}

async function getMetadataFromFile(path) {
	let edmx;
	edmx = await fs.read(path, "utf-8");
	return edmx;
}

async function getMetadataFromURL(url) {
	let edmx;
	const response = await axios.get(url);
	edmx = response["data"];
	if (edmx && (await _isValidXML(edmx))) {
		return edmx;
	} else {
		throw new Error(messages.INVALID_EDMX_METADATA);
	}
}

function _convertEDMXWithMultipleSchemas(edmx, multipleSchemas, namespace) {
	/*
		This is a quick hack only handling the following case we saw from SFSF:

		<edmx:DataServices>
			<Schema Namespace="SFODataSet">
				<EntityContainer>
					<EntitySet Name="Foos" EntityType="SFOData.Foo"> ... </EntitySet>
				</EntityContainer>
			</Schema>
			<Schema Namespace="SFOData">
				<EntityType Name="Foo"> ... </EntityType>
			</Schema>
		</edmx:DataServices>

		which is turned into that:

		<edmx:DataServices>
			<Schema Namespace="SFOData">
				<EntityContainer>
					<EntitySet Name="Foos" EntityType="SFOData.Foo"> ... </EntitySet>
				</EntityContainer>
				<EntityType Name="Foo"> ... </EntityType>
			</Schema>
		</edmx:DataServices>
	*/

	// Remove the ending and beginning of the first and second schema tag
	edmx = edmx.replace(multipleSchemas, '');
	// Now capture the schema tag details
	let schemaDetails = edmx.match(/(<Schema [^>]*>)/);
	// Replace the Namespace value with the correct one
	schemaDetails = schemaDetails[0].replace(/Namespace="[^"]+"/, `Namespace="${namespace}"`);
	// Place the above computed schema details in the edmx content
	edmx = edmx.replace(/(<Schema [^>]*>)/, `${schemaDetails}`);

	return edmx;
}

async function edmx2csn(edmx, filename, context) {
	const result = edmx.match(/EntityType="([^"]+)/);
	const multipleSchemas = /(\s*<\/Schema>\s*<Schema [^>]*>)\s*/m;
	if (!result) {
		throw new Error(messages.MISSING_ENTITIES);
	}
	const index = result[1].lastIndexOf(".");
	const namespace = (index > 0) ? result[1].substring(0, index) : result[1];

	if (multipleSchemas.test(edmx)) {
		edmx = _convertEDMXWithMultipleSchemas(edmx, multipleSchemas, namespace);
	}
	let csn = await generateCSN(edmx, false, true, context);
	const regex = /^[\p{Letter}\p{Nl}_]{1}[_\p{Letter}\p{Nl}\p{Nd}\p{Mn}\p{Mc}\p{Pc}\p{Cf}]{0,127}$/gu
	// Regex checks for this condition “A-B” must start with a letter or underscore, followed by at most 127 letters, underscores or digits in the fileName
	if (filename) {
		// Replace namespace by given filename in the csn file instead of edmx file
		const re = RegExp(`([("/])${namespace}([/").])`, 'g');
		let name = path.parse(filename).name;
		if (!(name.match(regex))) { // check if the filename is in the right format with the regex if not replace unaccepted characters with underscore (_)
			name = name.replace(/^[^a-z\p{Nl}_]/gui, '_');
			name = name.replace(/[^a-z0-9_\p{Nl}\p{Nd}\p{Mn}\p{Mc}\p{Pc}\p{Cf}]/gui, '_');
		}
		const fn = `$1${name}$2`;
		csn = csn.replace(re, fn);
	}
	return JSON.parse(csn);
}

async function _generateEDMX2JSON(edmx) {
	// Reinitialize
	let cjson = convert.xml2json(edmx, {
		compact: true,
		spaces: 4
	});
	return JSON.parse(cjson);
}

async function generateCSN(edmx, ignorePersistenceSkip, mockServerUc, context) {
	let csn;
	let odataVersion;
	let edmx2jsonModel;
	let defaultNamespaces;
	let namespaces = [];
	if(context.namespaces) namespaces.push(...(context.namespaces));
	odataVersion = await common.getVersion(edmx);
	if (odataVersion === "V2") {
		if(context){
			context.oDataVersion = "V2";
		}
		//default namespaces to be present
		if(!context.include_all_namespaces)
		{
			defaultNamespaces = ['edmx','sap','m'];
			namespaces = namespaces.concat(defaultNamespaces);
			namespaces = namespaces.filter((item,pos) => namespaces.indexOf(item) === pos); //removing duplicate values
		}
		context.namespaces = namespaces;
		edmx2jsonModel = await _generateEDMX2JSON(edmx);
		return new Promise(function getCsn(resolve, reject) {
			csn = edmxv2CSN.getEdmxv2CSN(
				edmx2jsonModel,
				ignorePersistenceSkip,
				mockServerUc,
				context
			);
			if (csn) {
				resolve(csn);
			} else {
				reject("Error Occurred");
			}
		});
	}
	else if (odataVersion === 'V4') {
		if(context){
			context.oDataVersion = "V4";
		}
		//default namespaces to be present
		if(!context.include_all_namespaces)
		{
			defaultNamespaces = ['edmx'];
			namespaces = namespaces.concat(defaultNamespaces);
			namespaces = namespaces.filter((item,pos) => namespaces.indexOf(item) === pos); //removing duplicate values
		}
		context.namespaces = namespaces;
		return edmxv4CSN.getEdmxv4CSN(edmx, ignorePersistenceSkip, mockServerUc, context);
	}
	return new Promise(function invalidFile(resolve, reject) {
		reject(new Error(messages.INVALID_EDMX_METADATA));
	});
}
async function saveCSNModel(csnDataModel, fileLoc) {
	await fs.write(fileLoc, csnDataModel, "utf-8");
}

module.exports = {
	isValidInputFile,
	validateAndComputeOutputFilePath,
	edmx2csn,
	getMetadataFromFile,
	getMetadataFromURL,
	generateCSN,
	saveCSNModel,
};
