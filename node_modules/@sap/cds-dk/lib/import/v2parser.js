/**
 * OData V2 to CSN parser
 */

"use strict";

let serviceNamespace;
let allEntities = [];
let allEntitiesMC = [];
let allEntitySetMap = {};
let allEntitySetMapMC = {};
let allEntitySetNamespaces = {};
let allFunctionImports = [];
let allFunctionImportsMap = {};
let allAssociations = {};
let allAssociationSets = {};
let allComplexTypes = {};
let allComplexTypeDocs = {};
let allComplexTypeNamespaces = {};
let allInheritedComplexTypes = {};
let allowedNamespaces = [];
let allowAllNamespaces = false;
let messages = require("./message").getMessages();
let common = require("./common");
let versionInfo = require('../../package.json').version;
const { warn } = require('@sap/cds/bin/utils/term');

let edmxncdsdatatype = {
	"Edm.String": "cds.LargeString",
	"Edm.Boolean": "cds.Boolean",
	"Edm.Int16": "cds.Integer",
	"Edm.Int32": "cds.Integer",
	"Edm.Int64": "cds.Integer64",
	"Edm.Decimal": "cds.DecimalFloat",
	"Edm.DateTime": "cds.DateTime", 
	"Edm.DateTimeOffset": "cds.DateTime",
	"Edm.Time": "cds.Time",
	"Edm.Binary": "cds.LargeBinary",
	"Edm.Guid": "cds.UUID",
	"Edm.Byte": "cds.Integer",
	"Edm.SByte": "cds.Integer",
	"Edm.Double": "cds.Double",
	// Special handling of data types
	"Edm.String_m": "cds.String", // Max length
	"Edm.Decimal_p": "cds.Decimal", // Precision, scale
	"Edm.DateTime_f": "cds.Date", // sap:display-format="Date"
	"Edm.DateTimeOffset_f": "cds.Date", // sap:display-format="Date"
	"Edm.Binary_m": "cds.Binary", // Max Length
	"Edm.Byte_m": "cds.Integer", // Max Length
	"Edm.Double_p": "cds.Double", // Precision, scale
	// Special handling with annotations
	"Edm.Single_a": "cds.Double",
	"Edm.Stream_a" : "cds.LargeBinary",
	"Edm.DateTimeOffset_a" : "cds.Timestamp", //precision > 0
	"Edm.DateTime_a" : "cds.Timestamp" //precision > 0
};

function _initialize() {
	allEntities.length = 0;
	allEntitiesMC.length = 0;
	allEntitySetMap = {};
	allEntitySetMapMC = {};
	allFunctionImports.length = 0;
	allFunctionImportsMap = {};
	allAssociations = {};
	allAssociationSets = {};
	allComplexTypes = {};
	allComplexTypeDocs = {};
	allComplexTypeNamespaces = {};
	allInheritedComplexTypes = {};
	allowedNamespaces = [];
	allowAllNamespaces = false;
}

// Function to extract allowed namespace attributes from given set of attributes
function namespaceAttributeFilter(attributes) {
	let namespaceAttributes = allowAllNamespaces
		? Object.keys(attributes).filter((attr) => attr.includes(':'))
		: Object.keys(attributes).filter(
				(attr) =>
					attr.includes(':') &&
					allowedNamespaces.includes(attr.split(':')[0]));
			

	namespaceAttributes = namespaceAttributes.map(attribute => {
		const index = attribute.indexOf(':');
		let namespace = attribute.slice(0, index);
		let name = attribute.slice(index + 1);

		name = name.replace(/-/g, '.');

		let formattedAttribute = {};
		formattedAttribute[`${namespace}.${name}`] = _replaceSpecialCharacters(attributes[attribute]);
		return formattedAttribute;
	});

	return namespaceAttributes;
}

//Function to generate CSN for namespace attributes 
function _generateNamespaceAttributes(attributes, isBefore) {
	let csn = "";
	attributes.forEach((attr) => {
		let key = Object.keys(attr)[0];
		if (isBefore) csn = csn + ',\n';
		csn = csn + `"@${key}":"${attr[key]}"`;
		if (!isBefore) csn = csn + ',\n';
	});

	return csn;
}
function _isValidEDMX(jsonObj) {
	let isValid = false;
	let edmx;
	let dataServices;
	let schema;
	if (jsonObj) {
		edmx = jsonObj["edmx:Edmx"];
		if (edmx) {
			dataServices = edmx["edmx:DataServices"];
			if (dataServices) {
				schema = dataServices.Schema;
				if (schema) {
					isValid = true;
				}
			}
		}
	}
	return isValid;
}

function _hasEntityContainer(jsonObj) {
	let isEntityContainerPresent = !!jsonObj["edmx:Edmx"]["edmx:DataServices"]
		.Schema.EntityContainer;
	if (!isEntityContainerPresent) {
		throw new Error(messages.MISSING_ENTITY_CONTAINER);
	}
	return isEntityContainerPresent;
}

function _hasEntitySet(jsonObj) {
    let isEntitySetPresent = !!jsonObj['edmx:Edmx']['edmx:DataServices'].Schema.EntityContainer.EntitySet;
    if (!isEntitySetPresent) {
        throw new Error(messages.MISSING_ENTITY_SETS);
    }
    return isEntitySetPresent;
}

function _isValidEDMXProvided(jsonObj) {
	let isValid = false;
	if (_isValidEDMX(jsonObj)) {
		isValid = true;
	} else {
		throw new Error(messages.INVALID_EDMX_METADATA);
	}
	return isValid;
}

function _validateEDMX(jsonObj) {
	return (
		_isValidEDMXProvided(jsonObj) &&
		_hasEntityContainer(jsonObj) &&
		_hasEntitySet(jsonObj)
	);
}

function _getServiceNameSpace(jsonObj) {
	let schemaArr = jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema;
	let schema = schemaArr;
	let schemaAttributes;
	if (Array.isArray(schemaArr)) {
		// TODO: Consider multiple schema.
		schema = schemaArr[0];
		// throw (messages.MULTIPLE_SCHEMA_FOUND);
	}
	Object.keys(schema).forEach((key) => {
		if (key === "_attributes") {
			schemaAttributes = schema[key];
		}
	});
	if (schemaAttributes) {
		return schemaAttributes.Namespace;
	}
	return null;
}

function _extractAssociationSet(associationSet) {
	let associations = {};
	Object.keys(associationSet).forEach((key) => {
		if (key === "_attributes") {
			associations.Name = associationSet[key].Name;
			associations.End = associationSet.End;
			// allAssociationSets[associationSet[key]['Association']] = associationSet['End'];
			allAssociationSets[associationSet[key].Association] = associations;
		}
	});
}

function _extractAllAssociationSets(associationSets) {
	let i;
	if (associationSets.length) {
		// Has many association sets in metadata
		for (i = 0; i < associationSets.length; i++) {
			_extractAssociationSet(associationSets[i]);
		}
	} else {
		// Has only one association set in metadata
		_extractAssociationSet(associationSets);
	}
}

function _extractAssociation(association) {
	Object.keys(association).forEach((key) => {
		if (key === "_attributes") {
			allAssociations[association[key].Name] = association;
		}
	});
}

function _extractAllAssociations(associations) {
	let i;
	if (associations.length) {
		// Has many associations in metadata
		for (i = 0; i < associations.length; i++) {
			_extractAssociation(associations[i]);
		}
	} else {
		// Has only one association in metadata
		_extractAssociation(associations);
	}
}

function _extractEntityFromNamespace(entityName) {
	if (!entityName)	
		return;
	let entityId = "";
	let pos = entityName.lastIndexOf(".");
	if (pos < 0) {
		return entityId;
	}
	entityId = entityName.substring(pos + 1);
	return entityId;
}

function _extractEntityFromEntitySet(entitySet) {
	let entityName;
	Object.keys(entitySet).forEach((key) => {
		if (key === "_attributes") {
			allEntitySetMap[entitySet[key].Name] = entitySet[key].EntityType;
			if (allEntitySetMapMC[entitySet[key].EntityType] === undefined)
				allEntitySetMapMC[entitySet[key].EntityType] = [];
			allEntitySetMapMC[entitySet[key].EntityType].push(entitySet[key].Name);
			entityName = _extractEntityFromNamespace(entitySet[key].EntityType);
			let namespaces = namespaceAttributeFilter(entitySet[key]);
			if(namespaces.length)
				allEntitySetNamespaces[entitySet[key].Name] = namespaces;
			allEntities.push(entityName);
			allEntitiesMC.push(entitySet[key].Name);
		}
	});
}

function _extractAllEntityFromEntitySets(entitySets) {
	let i;
	if (entitySets.length) {
		// Has many entity sets in metadata
		for (i = 0; i < entitySets.length; i++) {
			_extractEntityFromEntitySet(entitySets[i]);
		}
	} else {
		// Has only one entity sets in metadata
		_extractEntityFromEntitySet(entitySets);
	}
}

function _extractNameFromFunctionImport(entityName) {
	let entityId = "";
	let pos = entityName.lastIndexOf("_");
	if (pos < 0) {
		return entityName;
	}
	entityId = entityName.substring(pos + 1);
	return entityId;
}

function _getFunctionAttributes(functionImport, serviceNamespaceParam)
{
	let funcAttributes = [];
	if(functionImport["_attributes"])
	{
		funcAttributes.push(serviceNamespaceParam + _extractNameFromFunctionImport(functionImport["_attributes"].Name));
		funcAttributes.push(functionImport["_attributes"]["m:HttpMethod"]);
		if(functionImport["_attributes"].ReturnType)
		{
			funcAttributes.push(functionImport["_attributes"].ReturnType);
		} else {
			funcAttributes.push(-1);
		}
	}

	if(functionImport["Parameter"])
	{
		funcAttributes.push(functionImport["Parameter"]);
	} else {
		funcAttributes.push(-1);
	}

	if(functionImport["Documentation"])
	{
		funcAttributes.push(_parseDocumentationTag(functionImport["Documentation"]));
	} else {
		funcAttributes.push(-1);
	}

	return funcAttributes;
}

function _extractFunctionImport(functionImport, serviceNamespaceParam)
{
	//extracting the bounded and unbounded function import
	let boundedFunctionImports = [];
	let entityName;
	Object.keys(functionImport).forEach((key) => {
		if(key === "_attributes") {
			if(functionImport[key]["sap:action-for"])
			{
				//storing bounded function imports 
				entityName = _extractEntityFromNamespace(functionImport[key]["sap:action-for"]);
				boundedFunctionImports = (allFunctionImportsMap[entityName]) ? allFunctionImportsMap[entityName] : [];
				boundedFunctionImports.push(_getFunctionAttributes(functionImport,""));
				allFunctionImportsMap[entityName] = boundedFunctionImports;
			}
			else
			{
				//storing unbounded function imports
				allFunctionImports.push(_getFunctionAttributes(functionImport,serviceNamespaceParam + "."));
			}
		}
	});
}

//extracting the function imports from the metadata
function _extractAllFunctionImports(functionImports, serviceNamespaceParam)
{
	let i;
	if (functionImports.length) {
		//Has many function imports in metadata
		for (i = 0; i < functionImports.length; i++) {
			_extractFunctionImport(functionImports[i], serviceNamespaceParam);
		}
	} else {
		//Has only one function import in metadata
		_extractFunctionImport(functionImports, serviceNamespaceParam);
	}
}

function _replaceSpecialCharacters(text) {
    return text.replace(/(?:\\[rn]|[\r\n]+)+/gm, "\\n").replace(/\s+/g, ' ').replace(/"/g, "&quot;").trim();
}

// to parse the documentation tag
function _parseDocumentationTag(documentedContent) {
	let documentation = "";
	if (documentedContent.Summary && documentedContent.Summary._text) {
		documentation = _replaceSpecialCharacters(documentedContent.Summary._text);
	}	
	if (documentedContent.LongDescription && documentedContent.LongDescription._text) {
		if (documentedContent.Summary)
			documentation += "\\n\\n";
		documentation += _replaceSpecialCharacters(documentedContent.LongDescription._text);
	}
	return documentation;
}

function _extractComplexType(complexType, serviceNamespaceParam) {
	let complexTypeKey = "";
	let baseType = "";
	let properties;
	let namespaceAttributes = {};
	Object.keys(complexType).forEach((key) => {
		if (key === "_attributes") {
			complexTypeKey =
				serviceNamespaceParam + "." + complexType[key].Name;
			namespaceAttributes = namespaceAttributeFilter(complexType[key]);
			baseType = complexType[key].BaseType;
		} else if (key === "Property") {
			properties = complexType.Property;
		} else if (key === "Documentation") {
			allComplexTypeDocs[complexTypeKey] = _parseDocumentationTag(complexType.Documentation);
		}
	});
	allComplexTypes[complexTypeKey] = properties;
	if (complexTypeKey && baseType) {
		allInheritedComplexTypes[complexTypeKey] = baseType;
	}
	if (namespaceAttributes.length) {
		allComplexTypeNamespaces[complexTypeKey] = namespaceAttributes;
	}
}

function _extractAllComplexTypes(complexTypes, serviceNamespaceParam) {
	let i;
	if (complexTypes.length) {
		// Has many complex types in metadata
		for (i = 0; i < complexTypes.length; i++) {
			_extractComplexType(complexTypes[i], serviceNamespaceParam);
		}
	} else {
		// Has only one association in metadata
		_extractComplexType(complexTypes, serviceNamespaceParam);
	}
}

function _getServiceEntityProperty(
	propertyName,
	dataType,
	length,
	precision,
	scale,
	displayFormat,
	isKey,
	documentation,
	allowedNamespaceAttributes = -1
) {
	let isCollection = -1;
	//preprocessing of datatype in case it is a collection
	if(dataType.substring(0,10) === 'Collection')
	{
		dataType = dataType.substring(11,dataType.length-1);
		isCollection = 1;
	}

	//if primary key is of type Collection, an error is thrown
	if (isKey && isCollection === 1) {
		throw new Error(messages.COLLECTION_IN_KEY);
	}

	let cdsDataType = null;
	let hasInvalidPrecision = false;
	let propertyJson='';
	if (length && length > 0) {
		cdsDataType = edmxncdsdatatype[dataType + "_m"];
	} else if (precision && precision > 0) {
		cdsDataType = edmxncdsdatatype[dataType + "_p"];
		// Falling back to actual data type as precision has no meaning for 'Date' related data types
		// Using _a data type if precision is there for 'Date' related data types
		if (cdsDataType === undefined) {
			cdsDataType = edmxncdsdatatype[dataType + "_a"];
			hasInvalidPrecision = true;
		}
	} else if (displayFormat && displayFormat === "Date") {
		cdsDataType = edmxncdsdatatype[dataType + "_f"];
	} else {
		cdsDataType = edmxncdsdatatype[dataType];
	}

	//checks if it's an annotation case
	if (!cdsDataType) {
		cdsDataType = edmxncdsdatatype[dataType + "_a"];
	}
	// Lookup from complex type properties
	if (!cdsDataType && allComplexTypes[dataType]) {
		cdsDataType = dataType;
	}

	// Lookup from inherited complex type properties
	if (!cdsDataType && allInheritedComplexTypes[dataType]) {
		cdsDataType = dataType;
	}

	//Possibility of entity type or entity set as the data type
	if (!cdsDataType && allEntitySetMapMC[dataType]) {
		cdsDataType = serviceNamespace + "." + allEntitySetMapMC[dataType][0];
	} else if(!cdsDataType && allEntitySetMap[_extractEntityFromNamespace(dataType)]) {
		cdsDataType = dataType;
	}

	//if the cdsDataType is undefined/ not supported
	if(cdsDataType === undefined)
	{
		let message = '"' + dataType + '" is not supported'; 
		if(propertyName)
			message += ' (in element:"' + propertyName + '")';
		else
			message += ' (in return type)'
		console.log(warn(message));
		return "";
	}

	if(propertyName)
		propertyJson = '"' + propertyName + '": {\n';

	if (isKey) {
		propertyJson = propertyJson + '"key": true,\n';
	}
	if(isCollection === 1)
	{
		propertyJson = propertyJson + '"items": { \n'
	}
	propertyJson = propertyJson + '"type":"' + cdsDataType + '"';

	//if annotations to be added
	if(edmxncdsdatatype[dataType + "_a"] && cdsDataType != "cds.Date")
	{
		propertyJson = propertyJson + ',\n"@odata.type": "' + dataType + '"'; 
	}

	if (length && length > 0) {
		propertyJson = propertyJson + ',\n"length":' + length;
	} else if (precision && precision > 0 && hasInvalidPrecision === false) {
		propertyJson = propertyJson + ',\n"precision":' + precision;
		if (scale && scale > 0) {
			propertyJson = propertyJson + ',\n"scale":' + scale;
		} else {
			propertyJson = propertyJson + ',\n"scale":' + 0;
		}
	}
	
	//adding precision in case of DateTime datatypes
	if((dataType === "Edm.DateTimeOffset" || dataType === "Edm.DateTime") && cdsDataType != "cds.Date")
	{
		if(!precision || precision === -1) precision = 0;
		propertyJson = propertyJson + ',\n"@odata.precision": ' + precision;
	}

	if(isCollection === 1)
	{
		propertyJson = propertyJson + '\n}'
	}
	if(documentation != -1 && documentation){
		propertyJson = propertyJson + ',\n"doc":"' + documentation + '"';
	}

	if (allowedNamespaceAttributes !== -1) {
		propertyJson += _generateNamespaceAttributes(allowedNamespaceAttributes, true);
	}

	if(propertyName)
		propertyJson = propertyJson + "\n}";
	return propertyJson;
}

function _getServiceComplexType(complexTypeKey, complexType) {
	let complexTypeCSN = '"' + complexTypeKey + '": {\n';
	let complexTypeProperty;
	let i;
	complexTypeCSN = complexTypeCSN + '"kind": "type",\n';
	if(allComplexTypeNamespaces[complexTypeKey]) {
		complexTypeCSN += _generateNamespaceAttributes(allComplexTypeNamespaces[complexTypeKey], false);
	}
	if (allComplexTypeDocs[complexTypeKey])
		complexTypeCSN = complexTypeCSN + '"doc":' + `"${allComplexTypeDocs[complexTypeKey]}",` + "\n";
	complexTypeCSN = complexTypeCSN + '"elements": {\n';
	if (complexType) {
		if (complexType.length) {
			// More than one complex types
			for (i = 0; i < complexType.length; i++) {
				complexTypeProperty = complexType[i]._attributes;
				if(complexType[i].Documentation)
					complexTypeProperty.doc = _parseDocumentationTag(complexType[i].Documentation);
				let namespaceAttributes = namespaceAttributeFilter(complexTypeProperty)	
				const complexTypePropertyNamespace = namespaceAttributes.length ? namespaceAttributes : -1
					
				let complexProperty =
					_getServiceEntityProperty(
						complexTypeProperty.Name,
						complexTypeProperty.Type,
						complexTypeProperty.MaxLength,
						complexTypeProperty.Precision,
						complexTypeProperty.Scale,
						complexTypeProperty["sap:display-format"],
						false,
						complexTypeProperty.doc,
						complexTypePropertyNamespace
					);
				complexTypeCSN = complexTypeCSN + complexProperty;
				if (i !== complexType.length - 1 && complexProperty != "") {
					complexTypeCSN = complexTypeCSN + ",\n";
				} else {
					complexTypeCSN = complexTypeCSN + "\n";
				}
			}
		} else {
			// Only one complex type
			complexTypeProperty = complexType._attributes;
			if(complexType.Documentation)
				complexTypeProperty.doc = _parseDocumentationTag(complexType.Documentation);

			let namespaceAttributes = namespaceAttributeFilter(complexTypeProperty);
			const complexTypePropertyNamespace = namespaceAttributes.length ? namespaceAttributes : -1;
			
			complexTypeCSN =
				complexTypeCSN +
				_getServiceEntityProperty(
					complexTypeProperty.Name,
					complexTypeProperty.Type,
					complexTypeProperty.MaxLength,
					complexTypeProperty.Precision,
					complexTypeProperty.Scale,
					complexTypeProperty["sap:display-format"],
					false,
					complexTypeProperty.doc,
					complexTypePropertyNamespace
				);
		}

		if (complexTypeCSN && (complexTypeCSN.endsWith(",\n") || complexTypeCSN.endsWith(",\n\n"))) {
			complexTypeCSN = complexTypeCSN.substring(0, complexTypeCSN.lastIndexOf(",\n")) + "\n";
		}
	}
	complexTypeCSN = complexTypeCSN + "}\n";
	if (allInheritedComplexTypes[complexTypeKey]) {
		complexTypeCSN = complexTypeCSN + ",\n";
		complexTypeCSN =
			complexTypeCSN +
			'"includes": ["' +
			allInheritedComplexTypes[complexTypeKey] +
			'"]\n';
	}
	complexTypeCSN = complexTypeCSN + "}\n";
	return complexTypeCSN;
}

function _getServiceComplexTypes() {
	let complexTypeCSN = "";
	let complexTypesKeys = Object.keys(allComplexTypes);
	let i;
	let complexTypeKey;
	let complexType;
	for (i = 0; i < complexTypesKeys.length; i++) {
		complexTypeKey = complexTypesKeys[i];
		complexType = allComplexTypes[complexTypesKeys[i]];
		complexTypeCSN =
			complexTypeCSN +
			_getServiceComplexType(complexTypeKey, complexType);
		if (i !== complexTypesKeys.length - 1) {
			complexTypeCSN = complexTypeCSN + ",\n";
		} else {
			complexTypeCSN = complexTypeCSN + "\n";
		}
	}
	return complexTypeCSN;
}

function _parseParameter(parameter)
{
	let csn = "";
	let doc;
	if(parameter.Documentation)
		doc = _parseDocumentationTag(parameter.Documentation);

	let namespaceAttributes = namespaceAttributeFilter(parameter._attributes);
	const parameterNamespaceAttributes = namespaceAttributes.length ? namespaceAttributes : -1;

	csn = csn + _getServiceEntityProperty(parameter["_attributes"].Name,
				parameter["_attributes"].Type,
				parameter["_attributes"].MaxLength,
				parameter["_attributes"].Precision,
				parameter["_attributes"].Scale,
				parameter["_attributes"]["sap:display-format"],
				false,
				doc,
				parameterNamespaceAttributes);
	return csn;
}

function _checkParameterKey(parameter, entityKeysList){
	if ( entityKeysList && (Object.values(entityKeysList).indexOf(parameter._attributes.Name) > -1)){
		return true;
	}
	return false;	
}

function  _parseParametersFunctionImport(parameters, isBounded, entityKeysList) {
	let csn = "";
	let parameterCsn = "";
	let i = 0;
	if(parameters.length)
	{
		for (i; i < parameters.length; i++) {
			// check if the parameter is a key of the entity type or not
			// If yes then that paramater is ignored in CSN 
			let isKey = _checkParameterKey(parameters[i], entityKeysList);
			if (isKey == false) {
				parameterCsn = _parseParameter(parameters[i]);
				csn = csn + parameterCsn;
				if (i !== parameters.length - 1 && parameterCsn != "") {
					csn = csn + ",\n";
				} else {
					csn = csn + "\n";
				}
			}
		}
	} else {
		let isKey = _checkParameterKey(parameters);
		if (isKey === false) {
			csn = csn + _parseParameter(parameters);
		}
	}

	if (csn && (csn.endsWith(",\n") || csn.endsWith(",\n\n"))) {
		csn= csn.substring(0, csn.lastIndexOf(",\n")) + "\n";
	}
	return csn;
}

function _getFunctionImport(functionImport,isBounded,entityKeysList) {
	let noValue;
	let csn = "";
	csn = csn + '"' + functionImport[0] + '": { \n';
	csn = csn + '"kind": "';
	if(functionImport[1] === "GET")
	{
		csn = csn + "function";
	} else if(functionImport[1] === "POST")
	{
		csn = csn + "action";
	} else {
		let message = functionImport[0].substring(functionImport[0].lastIndexOf(".") + 1) + " has kind " + functionImport[1] + " which is not supported.";
		console.log(warn(message));
		return "";
	}
	csn = csn + '"';
	if(functionImport[3] !== -1)
	{
		if(isBounded === 0 || (isBounded === 1 && functionImport[3] instanceof Array ))
		{
			let parametersCsn = _parseParametersFunctionImport(functionImport[3],isBounded,entityKeysList);
			if(parametersCsn != "")
			{
				csn = csn + ", \n";
				csn = csn + '"params": { \n';
				csn = csn + parametersCsn;
				csn = csn + '\n }';
			}
		}
	}
	if(functionImport[2] !== -1)
	{
		let returnCsn = _getServiceEntityProperty(noValue,functionImport[2],noValue,noValue,noValue,noValue,noValue,noValue);
		if(returnCsn != "")
		{
			csn = csn + ", \n";
			csn = csn + '"returns": { \n';
			//return type
			csn = csn + returnCsn;
			csn = csn + '\n }';
		}
	}
	if(functionImport[4] !== -1 && functionImport[4])
	{
		csn = csn + ',\n "doc": "' + _replaceSpecialCharacters(functionImport[4]) + '"';
	}

	csn = csn + "\n }";
	return csn;
}

function _getAllFunctionImports(functionImports,isBounded,entityKeysList) {
	let functionImportsCSN = "";
	let i;
	let functionImportCSN = "";
	for(i=0; i<functionImports.length;i++)
	{
		functionImportCSN = _getFunctionImport(functionImports[i],isBounded, entityKeysList);
		functionImportsCSN = functionImportsCSN + functionImportCSN;
		if(i!== functionImports.length - 1 && functionImportCSN !== "" ) {
			functionImportsCSN = functionImportsCSN + ",\n";
		} else {
			functionImportsCSN = functionImportsCSN + "\n";
		}
	}

	//if last function import is omitted, remove the extra characters
	if (functionImportsCSN && (functionImportsCSN.endsWith(",\n") || functionImportsCSN.endsWith(",\n\n"))) {
		functionImportsCSN= functionImportsCSN.substring(0, functionImportsCSN.lastIndexOf(",\n")) + "\n";
	}
	return functionImportsCSN;
}

function _getEntityName(entity) {
	return entity._attributes.Name;
}

function _parseEntityAttributes(attributes) {
	let entityAttributes = {};
	// Extract only needed entity attributes
	entityAttributes.Name = attributes.Name;
	entityAttributes.BaseType = attributes.BaseType;
	entityAttributes.Abstract = attributes.Abstract;
	entityAttributes.allowedNamespaceAttributes = namespaceAttributeFilter(attributes);

	return entityAttributes;
}

function _parseEntityKeys(keys) {
	// Care for array or non-array (only one property as key)
	let retKeys = [];
	let i;
	let attributes;
	if (keys.PropertyRef.length) {
		for (i = 0; i < keys.PropertyRef.length; i++) {
			attributes = keys.PropertyRef[i]._attributes;
			retKeys.push(attributes.Name);
		}
	} else {
		retKeys.push(keys.PropertyRef._attributes.Name);
	}
	return retKeys;
}

function _getPropertyAttributes(propAttributes) {
	let propOthers = [];

	let namespaceAttributes = namespaceAttributeFilter(propAttributes)

	propOthers.push(propAttributes.Type);
	if (propAttributes.MaxLength) {
		propOthers.push(propAttributes.MaxLength);
	} else {
		propOthers.push(-1);
	}
	if (propAttributes.Precision) {
		propOthers.push(propAttributes.Precision);
	} else {
		propOthers.push(-1);
	}

	if (propAttributes.Scale) {
		propOthers.push(propAttributes.Scale);
	} else {
		propOthers.push(-1);
	}

	if (propAttributes["sap:display-format"]) {
		propOthers.push(propAttributes["sap:display-format"]);
	} else {
		propOthers.push(-1);
	}

	if(propAttributes.doc){
		propOthers.push(propAttributes.doc.replace(/"/g, '&quot;'));
	}else{
		propOthers.push(-1);
	}

	if (namespaceAttributes.length) {
		propOthers.push(namespaceAttributes);
	} else {
		propOthers.push(-1);
	}

	return propOthers;
}

function _parseEntityProperty(properties) {
	let propAttributes;
	let retProperties = {};
	let i;
	if (properties.length) {
		// Has more than one entities
		for (i = 0; i < properties.length; i++) {
			propAttributes = properties[i]._attributes;
			// if the property contains documentatin tag
			if(properties[i] && properties[i].Documentation)	
				propAttributes.doc = _parseDocumentationTag(properties[i].Documentation);
			retProperties[propAttributes.Name] = _getPropertyAttributes(propAttributes);
		}
	} else {
		// Has only one entity
		propAttributes = properties._attributes;
		// if the property contains documentatin tag
		if(properties && properties.Documentation)
			propAttributes.doc = _parseDocumentationTag(properties.Documentation);
		retProperties[propAttributes.Name] = _getPropertyAttributes(propAttributes);
	}
	return retProperties;
}

function _parseNavigationProperty(navigationProperties) {
	let retNavProperties = {};
	let navPropAttributes;
	let i;
	if (navigationProperties.length) {
		// Has more than one navigation property
		for (i = 0; i < navigationProperties.length; i++) {
			navPropAttributes = navigationProperties[i]._attributes;
			// if the property contains documentatin tag
			if(navigationProperties[i] && navigationProperties[i].Documentation)
				navPropAttributes.doc = _parseDocumentationTag(navigationProperties[i].Documentation);
			retNavProperties[navPropAttributes.Name] = navPropAttributes;
		}
	} else {
		// Has only one navigation property
		navPropAttributes = navigationProperties._attributes;
		// if the property contains documentatin tag
		if(navigationProperties && navigationProperties.Documentation)
			navPropAttributes.doc = _parseDocumentationTag(navigationProperties.Documentation);
		retNavProperties[navPropAttributes.Name] = navPropAttributes;
	}
	return retNavProperties;
}

function _generateCSNEntityKeys(entityKeysList, entityPropertiesMap) {
	let csnEntity = "";
	let propAttributes;
	let i;
	for (i = 0; i < entityKeysList.length; i++) {
		propAttributes = entityPropertiesMap[entityKeysList[i]];
		let keyCsn =
			_getServiceEntityProperty(
				entityKeysList[i],
				propAttributes[0],
				propAttributes[1],
				propAttributes[2],
				propAttributes[3],
				propAttributes[4],
				true,
				propAttributes[5],
				propAttributes[6]
			);
		csnEntity = csnEntity + keyCsn;
		if (i !== entityKeysList.length - 1 && keyCsn != "") {
			csnEntity = csnEntity + ",\n";
		}
	}
	if (csnEntity && (csnEntity.endsWith(",\n") || csnEntity.endsWith(",\n\n"))) {
		csnEntity= csnEntity.substring(0, csnEntity.lastIndexOf(",\n")) + "\n";
	}
	return csnEntity;
}

function _generateCSNEntityProperties(entityKeysList, entityPropertiesMap) {
	let csnEntity = "";
	let entityProperties = Object.keys(entityPropertiesMap);
	let i;
	let property;
	let propAttributes;
	if (entityKeysList.length > 0) {
		if (entityProperties.length > 0) {
			csnEntity = csnEntity + ",\n";
		} else {
			csnEntity = csnEntity + "\n";
		}
	}
	for (i = 0; i < entityProperties.length; i++) {
		property = entityProperties[i];
		// Include Property which are not part of keys
		if (entityKeysList.indexOf(property) === -1) {
			propAttributes = entityPropertiesMap[property];
			let propertyString =
				_getServiceEntityProperty(
					property,
					propAttributes[0],
					propAttributes[1],
					propAttributes[2],
					propAttributes[3],
					propAttributes[4],
					false,
					propAttributes[5],
					propAttributes[6]
				);
			csnEntity = csnEntity + propertyString;
			if (i !== entityProperties.length - 1 && propertyString != "") {
				csnEntity = csnEntity + ",\n";
			} else {
				csnEntity = csnEntity + "\n";
			}
		}
	}
	// Last property can be an key; eliminate additional delimiter.
	// Last property can have undefined datatype and be ignored too
	//doubt
	if (csnEntity && (csnEntity.endsWith(",\n") || csnEntity.endsWith(",\n\n"))) {
		csnEntity = csnEntity.substring(0, csnEntity.lastIndexOf(",\n")) + "\n";
	}
	return csnEntity;
}

function _getAssociatedEntity(associationEnds, toRole, mockServerUc) {
	let entityName;
	let entitySetName;
	Object.keys(associationEnds).forEach((i) => {
		if (toRole === associationEnds[i]._attributes.Role) {
			entitySetName = associationEnds[i]._attributes.EntitySet;
			if (mockServerUc) {
				entityName = serviceNamespace + "." + entitySetName;
			} else {
				entityName = allEntitySetMap[entitySetName];
			}
		}
	});
	return entityName;
}

function _getCSNMultiplicity(
	associationEnds,
	toRole,
	entityName,
	mockServerUc
) {
	let csn = "";
	let multiplicity;
	let attributes;
	let stop = false;
	Object.keys(associationEnds).forEach((i) => {
		if (!stop) {
			attributes = associationEnds[i]._attributes;
			if (mockServerUc) {
				let entityNameWithOutNS =
					allEntitySetMap[_extractEntityFromNamespace(entityName)];
				if (
					toRole === attributes.Role &&
					entityNameWithOutNS === attributes.Type
				) {
					multiplicity = attributes.Multiplicity;
					stop = true;
				}
			} else {
				if (
					toRole === attributes.Role &&
					entityName === attributes.Type
				) {
					// eslint-disable-line no-lonely-if
					multiplicity = attributes.Multiplicity;
					stop = true;
				}
			}
		}
	});
	if (multiplicity === "1" || multiplicity === "0..1") {
		// When multiplicity is '1' then in CSN we NO need to generate 'cardinality' section
		return csn;
	}
	if (multiplicity) {
		csn = csn + '"cardinality": {\n';
		csn = csn + '"max": "' + multiplicity + '"\n';
		csn = csn + "}";
	}
	return csn;
}

function _getCSNRefrenentialCondition(navPropName, from, to) {
	let csn = "{\n";
	csn = csn + '"ref": [\n';
	csn = csn + '"' + navPropName + '",\n';
	csn = csn + '"' + from + '"\n';
	csn = csn + "]\n";
	csn = csn + "},\n";

	csn = csn + '"=",\n';

	csn = csn + "{\n";
	csn = csn + '"ref": [\n';
	csn = csn + '"' + to + '"';
	csn = csn + "]\n";
	csn = csn + "}\n";
	return csn;
}

function _getCSNMultipleRefrenentialConditions(
	refConstraints,
	navPropName,
	role
) {
	let csn = "";
	csn = csn + '"on": [\n';
	Object.keys(refConstraints).forEach((i) => {
		let roleName = refConstraints[i].Principal._attributes.Role;
		let principalProperties = refConstraints[i].Principal.PropertyRef;
		let dependentProperties = refConstraints[i].Dependent.PropertyRef;
		let from = "";
		let to = "";
		if (roleName && roleName === role) {
			from = principalProperties._attributes.Name;
			to = dependentProperties._attributes.Name;
		} else {
			from = dependentProperties._attributes.Name;
			to = principalProperties._attributes.Name;
		}
		csn = csn + _getCSNRefrenentialCondition(navPropName, from, to);
		if (i < refConstraints.length - 1) {
			csn = csn + ",\n";
			csn = csn + '"and",\n';
		}
	});
	csn = csn + "]\n";
	return csn;
}

function _getCSNRefrenentialConditions(refConstraints, navPropName, role) {
	let csn = "";
	let from;
	let to;
	let roleName = refConstraints.Principal._attributes.Role;
	let principalProperties = refConstraints.Principal.PropertyRef;
	let dependentProperties = refConstraints.Dependent.PropertyRef;
	if (dependentProperties.length > 0) {
		// Multiple principal and dependents within Referential Constraint
		csn = csn + '"on": [\n';
		Object.keys(dependentProperties).forEach((i) => {
			if (roleName && roleName === role) {
				from = principalProperties[i]._attributes.Name;
				to = dependentProperties[i]._attributes.Name;
			} else {
				from = dependentProperties[i]._attributes.Name;
				to = principalProperties[i]._attributes.Name;
			}
			csn = csn + _getCSNRefrenentialCondition(navPropName, from, to);
			if (i < dependentProperties.length - 1) {
				csn = csn + ",\n";
				csn = csn + '"and",\n';
			}
		});
		csn = csn + "]\n";
	} else {
		// Single principal and dependents within Referential Constraint
		csn = csn + '"on": [\n';
		if (roleName && roleName === role) {
			from = principalProperties._attributes.Name;
			to = dependentProperties._attributes.Name;
		} else {
			from = dependentProperties._attributes.Name;
			to = principalProperties._attributes.Name;
		}
		csn = csn + _getCSNRefrenentialCondition(navPropName, from, to);
		csn = csn + "]\n";
	}
	return csn;
}

function _getCSNRefrenentialConstraints(associations, navPropName, toRole) {
	let csn = "";
	let endProperties;
	let matchingRole = "";
	let refConstraints = associations.ReferentialConstraint;
	if (!refConstraints) {
		return csn;
	}
	endProperties = associations.End;
	Object.keys(endProperties).forEach((i) => {
		let role = endProperties[i]._attributes.Role;
		if (role && role === toRole) {
			matchingRole = endProperties[i]._attributes.Role;
		}
	});
	if (refConstraints.length > 0) {
		// Multiple referential constraints within Association
		csn =
			csn +
			_getCSNMultipleRefrenentialConditions(
				refConstraints,
				navPropName,
				matchingRole
			);
	} else {
		// Single referential constraint within Association
		csn =
			csn +
			_getCSNRefrenentialConditions(
				refConstraints,
				navPropName,
				matchingRole
			);
	}
	return csn;
}

function _getCSNAssociatedRefrenentialConstraints(
	associations,
	toRole,
	entityName,
	navPropName,
	mockServerUc
) {
	let csn = "";
	let multiplicity;
	let referentialConstraint;
	csn = csn + '"target": "' + entityName + '"';
	if (!associations) {
		return csn;
	}
	multiplicity = _getCSNMultiplicity(
		associations.End,
		toRole,
		entityName,
		mockServerUc
	);
	if (multiplicity) {
		csn = csn + ",\n" + multiplicity;
	}
	referentialConstraint = _getCSNRefrenentialConstraints(
		associations,
		navPropName,
		toRole,
		mockServerUc
	);
	if (referentialConstraint) {
		csn = csn + ",\n" + referentialConstraint;
	}
	return csn;
}

function _getCSNAssociatedEntitySet(
	relationshipName,
	toRole,
	navPropName,
	mockServerUc
) {
	let associationSet = allAssociationSets[relationshipName];
	if(associationSet === undefined) {
		throw new Error(messages.MISSING_ASSOCIATION_SETS);
	}
	let associationName = associationSet.Name;
	let entityName = _getAssociatedEntity(
		associationSet.End,
		toRole,
		mockServerUc
	);
	let differentAssociationNames;
	if (!allAssociations[associationName]) {
		let array = relationshipName.split(".");
		if (
			array != "undefined" &&
			array != null &&
			array.length != null &&
			array.length > 0
		) {
			differentAssociationNames =
				allAssociations[array[array.length - 1]];
		}
	} else {
		differentAssociationNames = allAssociations[associationName];
	}
	return _getCSNAssociatedRefrenentialConstraints(
		differentAssociationNames,
		toRole,
		entityName,
		navPropName,
		mockServerUc
	);
}

function _getServiceEntityNavigationProperty(navPropAttributes, mockServerUc) {
	let csn = "";
	let navPropName;
	let relationshipName;
	let navPropDoc;
	let allowedNamespaceAttributes = namespaceAttributeFilter(navPropAttributes);
	// var fromRole;
	let toRole;
	if (!navPropAttributes) {
		return csn;
	}
	navPropName = navPropAttributes.Name;
	relationshipName = navPropAttributes.Relationship;
	// fromRole = navPropAttributes.FromRole;
	toRole = navPropAttributes.ToRole;
	navPropDoc = navPropAttributes.doc;

	csn = csn + '"' + navPropName + '": {\n';
	if(allowedNamespaceAttributes.length) {
		csn += _generateNamespaceAttributes(allowedNamespaceAttributes, false);
	}
	// annotation for on conditions
	csn = csn + `"@cds.ambiguous": "missing on condition?",\n`;
	// if documentation exists for navigation property
	if (navPropDoc)
		csn = csn + '"doc":' + ` "${navPropDoc}",\n`;
	csn = csn + '"type": "cds.Association",\n';
	csn = csn +
		_getCSNAssociatedEntitySet(
			relationshipName,
			toRole,
			navPropName,
			mockServerUc
		);
	// Convert managed associations and compositions in unmanaged with empty key to avoid
    // "generation" of keys, that do not exist in the external service.
	if (common.checkForEmptyKeys(csn, "V2")) {
		csn = csn + ',\n"keys": []\n';
	}
	csn = csn + "}";

	return csn;
}

function _generateCSNEntityNavigationProperties(
	entityNavigationPropertiesMap,
	hasProperties,
	mockServerUc
) {
	let csn = "";
	let i;
	let entityNavProperties;
	let navProperty;
	let navPropAttributes;
	if (!entityNavigationPropertiesMap) {
		return csn;
	}

	entityNavProperties = Object.keys(entityNavigationPropertiesMap);
	if (hasProperties && entityNavProperties.length > 0) {
		// Has navigation properties
		csn = ",\n";
	}
	for (i = 0; i < entityNavProperties.length; i++) {
		navProperty = entityNavProperties[i];
		navPropAttributes = entityNavigationPropertiesMap[navProperty];
		csn =
			csn +
			_getServiceEntityNavigationProperty(
				navPropAttributes,
				mockServerUc
			);
		if (i < entityNavProperties.length - 1) {
			csn = csn + ",\n";
		}
	}
	return csn;
}

function _getBaseTypeEntityName(entityName, serviceNamespaceParam) {
	let baseTypeName;
	// if one entity type has mapping to multiple entity sets, use the first entity set
	if (allEntitySetMapMC[entityName]) {
		baseTypeName = serviceNamespaceParam + "." + allEntitySetMapMC[entityName][0];
		return baseTypeName;
	}
	return entityName;
}

function _constructServiceEntity(
	serviceNamespaceParam,
	entityName,
	entityKeysList,
	entityPropertiesMap,
	entityNavigationPropertiesMap,
	entityAttributes,
	ignorePersistenceSkip,
	mockServerUc,
	documentation
) {
	let filteredNamespaces = {};
	let namespaces = [];
	let serviceEntityName = serviceNamespaceParam + "." + entityName;
	let csnEntity = '"' + serviceEntityName + '": {\n';
	let csnKeys;
	let csnProperties;
	let hasProperties;
	csnEntity = csnEntity + '"kind": "entity",\n';
	if (ignorePersistenceSkip === false) {	
		csnEntity = csnEntity + '"@cds.persistence.skip": true,\n';	
	}
	if (entityAttributes.Abstract && entityAttributes.Abstract.toUpperCase() === "TRUE") {
		csnEntity = csnEntity + '"abstract": true,\n';
	}

	/* Merging the namespace list from entity set and entity type
	And in case of same label, entity set's value will have precedence */
	if(allEntitySetNamespaces[entityName]){
		allEntitySetNamespaces[entityName].forEach((item) => {
			filteredNamespaces[Object.keys(item)[0]] = Object.values(item)[0];
		});
	}
	if(entityAttributes.allowedNamespaceAttributes.length){
		entityAttributes.allowedNamespaceAttributes.forEach((item) => {
			if(!filteredNamespaces[Object.keys(item)[0]]){
				filteredNamespaces[Object.keys(item)[0]] = Object.values(item)[0];
			}
		});
	}
	Object.keys(filteredNamespaces).forEach((item) => {
		let obj = {};
		obj[item] = filteredNamespaces[item];
		namespaces.push(obj)
	});

	if(namespaces)
		csnEntity += _generateNamespaceAttributes(namespaces, false);
	
	// if documentation exists for the entity
	if (documentation) {
		csnEntity = csnEntity + `"doc": "${documentation}",` + '\n';
	}
	csnEntity = csnEntity + '"elements": {\n';

	// Key Entity attributes
	csnKeys = _generateCSNEntityKeys(entityKeysList, entityPropertiesMap);

	// Non key Entity attributes
	csnProperties = _generateCSNEntityProperties(
		entityKeysList,
		entityPropertiesMap
	);
	csnProperties = csnKeys + csnProperties;
	//to remove additional ',\n' in case key datatype is undefined
	if (csnProperties && csnProperties.startsWith(",\n")) {
		csnProperties = csnProperties.substring(csnProperties.indexOf(",\n") + 2);
	}
	
	csnEntity = csnEntity + csnProperties;

	// No keys and No properties found
	hasProperties = true;
	if (csnKeys.trim() === "" && csnProperties.trim() === "") {
		hasProperties = false;
	}
	// Entity navigation properties
	csnEntity =
		csnEntity +
		_generateCSNEntityNavigationProperties(
			entityNavigationPropertiesMap,
			hasProperties,
			mockServerUc
		);
	csnEntity = csnEntity + "}\n";

	if (entityAttributes.BaseType) {
		let baseTypeName = _getBaseTypeEntityName(entityAttributes.BaseType, serviceNamespaceParam);
		csnEntity = csnEntity + ",\n";
		csnEntity = csnEntity + '"includes": ["' + baseTypeName + '"]\n';
	}

	//if the function import is bounded to entitySet 
	if (allFunctionImportsMap[entityName])
	{
		csnEntity = csnEntity + ', \n "actions": {\n';
		csnEntity = csnEntity + _getAllFunctionImports(allFunctionImportsMap[entityName],1,entityKeysList);
		csnEntity = csnEntity + "}";
	}
	else if (allFunctionImportsMap[_extractEntityFromNamespace(allEntitySetMap[entityName])]) //if the function import is bounded to entityType
	{
		csnEntity = csnEntity + ', \n "actions": {\n';
		csnEntity = csnEntity + _getAllFunctionImports(allFunctionImportsMap[_extractEntityFromNamespace(allEntitySetMap[entityName])],1,entityKeysList);
		csnEntity = csnEntity + "}";
	}

	return csnEntity;
}

function _parseServiceEntity(
	serviceNamespaceParam,
	entityName,
	entity,
	ignorePersistenceSkip,
	mockServerUc
) {
	let entityAttributes;
	let entityKeysList;
	let entityPropertiesMap;
	let entityNavigationPropertiesMap;
	let documentation;
	Object.keys(entity).forEach((key) => {
		if (key === "_attributes") {
			entityAttributes = _parseEntityAttributes(entity[key]);
		} else if (key.toUpperCase() === "Key".toUpperCase()) {
			entityKeysList = _parseEntityKeys(entity[key]);
		} else if (key.toUpperCase() === "Property".toUpperCase()) {
			entityPropertiesMap = _parseEntityProperty(entity[key]);
		} else if (key.toUpperCase() === "NavigationProperty".toUpperCase()) {
			entityNavigationPropertiesMap = _parseNavigationProperty(entity[key]);
		} else if (key.toUpperCase() === "Documentation".toUpperCase()) {
			documentation = _parseDocumentationTag(entity[key]);
		}
	});
	// No keys in entity
	if (entityKeysList === undefined || entityKeysList == null) {
		entityKeysList = [];
	}
	// No properties in entity
	if (entityPropertiesMap === undefined || entityPropertiesMap == null) {
		entityPropertiesMap = [];
	}
	// No navigation properties in entity
	if (entityNavigationPropertiesMap === undefined || entityNavigationPropertiesMap == null) {
		entityNavigationPropertiesMap = [];
	}
	// If inherited entity found
	if (entityAttributes.BaseType) {
		allEntities.push(
			_extractEntityFromNamespace(entityAttributes.BaseType)
		);
	}
	return _constructServiceEntity(
		serviceNamespaceParam,
		entityName,
		entityKeysList,
		entityPropertiesMap,
		entityNavigationPropertiesMap,
		entityAttributes,
		ignorePersistenceSkip,
		mockServerUc,
		documentation
	);
}

function _getEntitesWithNamesFromEntitySets(serviceNamespaceParam, entityJson, mockServerUc) {
	const getEntityName = mockServerUc
		? (entity) => allEntitySetMapMC[serviceNamespaceParam + "." + _getEntityName(entity)]
		: (entity) => [_getEntityName(entity)];

	const isNameInEntitySet = mockServerUc
		? (name) => allEntitiesMC.indexOf(name) >= 0
		: (name) => allEntities.indexOf(name) >= 0;

	const getEntitySetNames = entityWithName => {
		if (!entityWithName.name) return false;
		for (let i = 0; i < entityWithName.name.length; i++) {
			if (!isNameInEntitySet(entityWithName.name[i]))
				return false;
		}
		return true;
	};

	return entityJson
		.map((entity) => ({
			entity,
			name: getEntityName(entity)
		}))
		.filter((entityWithName) => getEntitySetNames(entityWithName));
}

function _getEntitesWithNamesFromEntityTypes(serviceNamespaceParam, entityJson) {
	let entities = [];
	// we are not making any decision here on the basis of mockserverUc variable as of now
	for (let i = 0; i < entityJson.length; i++) {
		let entity = _getEntityName(entityJson[i]);
		// if entity doesn't have any mapping with entity set,
		// then collect those entityType
		if (!allEntitySetMapMC[serviceNamespaceParam + "." + entity]) {
			entities.push( { 
				entity: entityJson[i], 
				name: [entity] 
			} );
		}
	}

	return entities;
}

function _parsingServiceEntities(
	entitiesWithNames,
	serviceNamespaceParam,
	ignorePersistenceSkip,
	mockServerUc
){
	return  entitiesWithNames.map((entityWithName) => 
				entityWithName.name.map((entityName) =>
					_parseServiceEntity(
						serviceNamespaceParam,
						entityName,
						entityWithName.entity,
						ignorePersistenceSkip,
						mockServerUc
					)
				).join("},") + "}"
			);
}

function _getServiceEntitites(
	serviceNamespaceParam,
	entityJson = [],
	ignorePersistenceSkip,
	mockServerUc
) {
	const entities = Array.isArray(entityJson) ? entityJson : [entityJson];
	let entitiesWithNames = []; // [0]-> entity set, [1]-> entity type
	let parsedEntities = []; // [0]-> entity set, [1]-> entity type

	entitiesWithNames[0] = _getEntitesWithNamesFromEntitySets(serviceNamespaceParam, entities, mockServerUc);
	entitiesWithNames[1] = _getEntitesWithNamesFromEntityTypes(serviceNamespaceParam, entities);

	for (let i = 0; i < 2; i++) {
		if (entitiesWithNames[i].length) {
			parsedEntities[i] = _parsingServiceEntities(entitiesWithNames[i],
				serviceNamespaceParam, ignorePersistenceSkip, mockServerUc);
		}
	}
	// if entities from entity set and entity type both are parsed
	if (parsedEntities[0] && parsedEntities[1])
		return parsedEntities[0].concat(parsedEntities[1]);
	else if (parsedEntities[0] && !parsedEntities[1])
		return parsedEntities[0];
	else if (!parsedEntities[0] && parsedEntities[1])
		return parsedEntities[1];

	return "";
}

function _generateEDMXJSON2CSN(
	jsonObj,
	serviceNamespaceParam,
	ignorePersistenceSkip,
	mockServerUc
) {
	const csn = {};
	csn.meta = {};
    csn.meta.creator = 'cds-dk ' + versionInfo;
	csn.$version = '2.0';
	csn.definitions = {};

	// Extract association sets
	let associationSets =
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.EntityContainer
			.AssociationSet;
	if (associationSets) {
		_extractAllAssociationSets(associationSets);
	}
	// Extract associations
	const associations =
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.Association;
	if (associations) {
		_extractAllAssociations(associations);
	}
	// Extract entities from EntitySets
	const entitySets =
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.EntityContainer
			.EntitySet;
	if (entitySets) {
		_extractAllEntityFromEntitySets(entitySets);
	}
	// Extract function imports
	const functionImports = 
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.EntityContainer
			.FunctionImport;
	if(functionImports) {
		_extractAllFunctionImports(functionImports, serviceNamespaceParam);
	}
	// Extract complex types
	const complexTypes =
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.ComplexType;
	if (complexTypes) {
		_extractAllComplexTypes(complexTypes, serviceNamespaceParam);
	}

	// Construct CSN entity based on EDMX entity
	const entityJson =
		jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema.EntityType;
	const definitions = [];

	if (mockServerUc) {
		let def  = '"' + serviceNamespaceParam + '": {"kind": "service"' + ',\n' + '"@cds.external": true';
		let serviceDoc = jsonObj["edmx:Edmx"]["edmx:DataServices"]["Schema"].EntityContainer.Documentation;
		let namespaceAttributes = namespaceAttributeFilter(jsonObj["edmx:Edmx"]["edmx:DataServices"]["Schema"].EntityContainer["_attributes"]);
		// if documentation exists for service
		if (serviceDoc) {
			let doc = _parseDocumentationTag(serviceDoc);
			if (doc) def += ',\n' + `"doc": "${doc}"`;
		}
		if(namespaceAttributes.length)
			def += _generateNamespaceAttributes(namespaceAttributes,true);
		def += "}";
		definitions.push(def);
	}

	// If complex type exists
	if (complexTypes) {
		definitions.push(_getServiceComplexTypes());
	}

	//if there are unbounded function imports
	if(Object.keys(allFunctionImports).length > 0)
	{
		definitions.push(_getAllFunctionImports(allFunctionImports,0,0)); //passing 0 for unbounded actions/functions and 0 for entityKeysList 
	}

	if (entityJson) {
		definitions.push(
			_getServiceEntitites(
				serviceNamespaceParam,
				entityJson,
				ignorePersistenceSkip,
				mockServerUc
			)
		);
	}

	try {
		csn.definitions = JSON.parse(`{${definitions.join(",")}}`);
		return JSON.stringify(csn, null, 4);
	} catch (error) {
		throw new Error("Unable to convert to csn file.");
	}
}

function getEdmxv2CSN(
	edmx2jsonModel,
	ignorePersistenceSkip,
	mockServerUc,
	context
) {
	let csnDataModel;
	let isValid;
	_initialize();
	if (!context.include_all_namespaces && context.namespaces.length) {
		allowedNamespaces = allowedNamespaces.concat(context.namespaces)
	}
	else if(context.include_all_namespaces) {
		allowAllNamespaces = true;
	} 

	isValid = _validateEDMX(edmx2jsonModel);
	if (isValid) {
		serviceNamespace = _getServiceNameSpace(edmx2jsonModel);
		let namespaceAlias = edmx2jsonModel["edmx:Edmx"]["edmx:DataServices"].Schema._attributes.Alias;
		// replace the namespace alias value with original namespace value
		if (namespaceAlias) {
			edmx2jsonModel = common.replaceAliasValue(JSON.stringify(edmx2jsonModel), serviceNamespace, namespaceAlias);
		}
		csnDataModel = _generateEDMXJSON2CSN(
			edmx2jsonModel,
			serviceNamespace,
			ignorePersistenceSkip,
			mockServerUc
		);
	}
	return csnDataModel;
}

module.exports = {
	getEdmxv2CSN
};
