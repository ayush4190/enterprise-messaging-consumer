'use strict';

let convert = require('xml-js')
function _isJson(edmx) {
    let isJson = false;
    try {
        JSON.parse(edmx);
        isJson = true;
    } catch (err) {
        isJson = false;
    }
    return isJson;
}

async function _generateEDMX2JSON(edmx) {
    // Reinitialize
    let cjson = convert.xml2json(edmx, {
        compact: true,
        spaces: 4
    });
    return JSON.parse(cjson);
}

function checkForEmptyKeys(element, oDataVersion) {
    if (oDataVersion === "V2") {
        return (element.includes(["cds.Association"]) && !element.includes(['"on":']));
    }
    else {
        return (['cds.Association'].includes(element.type)) && !element.on && !element.keys;
    }    
}

//to replace the alias value with original schema namespace value
function replaceAliasValue(schemaContent, schemaNamespaceValue, aliasValue){
    const re = RegExp(`([("/])${aliasValue}([/").])`, 'g');
    const val = `$1${schemaNamespaceValue}$2`;
    schemaContent = schemaContent.replace(re, val);
    return JSON.parse(schemaContent);
}

async function _getODataVersion(edmx) {
    let oDataVersion;
    let jsonObj;
    let dataServices;
    let dataServicesAttributes;
    // Check OData version
    if (_isJson(edmx)) {
        return '';
    }
    jsonObj = await _generateEDMX2JSON(edmx);
    try {
        dataServices = jsonObj['edmx:Edmx']['edmx:DataServices'];
        dataServicesAttributes = dataServices._attributes;
    } catch (err) {
        oDataVersion = '';
    }
    if (dataServicesAttributes) {
        oDataVersion = dataServicesAttributes['m:DataServiceVersion'];
    } else {
        // V4 edmx
        try {
            oDataVersion = jsonObj['edmx:Edmx']._attributes.Version;
        } catch (err) {
            oDataVersion = '';
        }
    }
    return oDataVersion;
}

async function _isOdataV2(fileInputStream) {
    let isV2 = false;
    // existing logic
    const version = await _getODataVersion(fileInputStream);
    if (version === '1.0' || version === '2.0') {
        isV2 = true;
    }
    return isV2;
}

async function _isOdataV4(fileInputStream) {
    let isV4 = false;
    let version;
    let edmj;
    if (_isJson(fileInputStream)) {
        edmj = JSON.parse(fileInputStream);
        version = edmj.$Version;
        // read $Version from JSON
    } else {
        version = await _getODataVersion(fileInputStream);
    }
    if (version === '4.0') {
        isV4 = true;
    }
    return isV4;
}

async function getVersion(fileInputStream) {
    // method to find the version
    // input can be JSON or XML
    // if xml, find the version
    // if json, find the version
    let oDataVersion;
    if (await _isOdataV2(fileInputStream)) {
        oDataVersion = 'V2';
    } else if (await _isOdataV4(fileInputStream)) {
        oDataVersion = 'V4';
    }
    return oDataVersion;
}

function getSuffix(outputFormat) {
    const suffix = { edmx: 'xml', "edmx-v2": 'xml', "edmx-v4": 'xml', "edmx-w4": 'xml',
        "edmx-x4": 'xml', openapi: 'openapi3.json', sql: 'sql', edm: 'json', "cdl": "cds" };
    // find the output file extension based on the target conversion selected
    return (outputFormat) ? (suffix[outputFormat] || outputFormat) : 'csn';
}

function supportedFormats() {
    return ["cds", "csn", "json"];
}

module.exports = {
    getVersion,
    getSuffix,
    supportedFormats,
    checkForEmptyKeys,
    replaceAliasValue
};
