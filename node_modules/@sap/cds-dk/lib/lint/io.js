const os = require("os");
const fsp = require("fs").promises;
const path = require("path");
const yaml = require("@sap/cds-foss")("yaml");
const term = require("../util/term");
const FsUtil = require("../init/util/fsUtil");
const fsUtil = new FsUtil();

const IS_WIN = os.platform() === "win32";

module.exports = {
  /**
   * Reads ESLint config contents from file
   * @param {*} configPath config file path to read from
   * @returns config file contents
   */
  async readEslintConfig(configPath) {
    let config;
    let configFile = path.basename(configPath);
    let configString = await fsp.readFile(configPath, "utf8");
    switch (configFile) {
      case ".eslintrc.js":
      case ".eslintrc.cjs":
        try {
          config = JSONC.parse((configString.replace(/^module\.exports =/, "")));
        } catch (err) {
          config = {};
        }
        break;
      case ".eslintrc.yaml":
      case ".eslintrc.yml":
        config = yaml.parse(await fsp.readFile(configPath, "utf8"));
        break;
      case ".eslintrc.json":
      case ".eslintrc":
        config = await fsUtil.readJSONC(configPath);
        break;
      case "package.json":
        config = JSON.parse(await fsp.readFile(configPath, "utf8"));
        if ("eslintConfig" in config) {
          config = config["eslintConfig"];
        } else {
          config = {}
        }
        break;
      default:
        break;
    }
    return config;
  },

  /**
   * Checks ESLint config file contents for locally installed
   * plugin with:
   * (1) All CDS recommended rules "on"
   * (2) Option "root": false to stop further config merging
   * (3) Add's custom rule example 'no-entity-moo' if requested
   * @param {*} configPath ESLint config file
   * @returns {void}
   */
  async sanitizeEslintConfig(configPath, customRuleExample = false, logger = console) {
    let configContents = {};
    if (await fsUtil.pathExists(configPath)) {
      configContents = (await this.readEslintConfig(configPath)) || {};
    }
    const configType = "recommended";
    const extendsValue = `plugin:@sap/cds/${configType}`;
    if ("extends" in configContents) {
      if (Array.isArray(configContents["extends"])) {
        if (!configContents["extends"].includes(extendsValue)) {
          configContents["extends"].push(extendsValue);
        }
      } else {
        if (configContents["extends"] !== extendsValue) {
          configContents["extends"] = [configContents["extends"], extendsValue];
        }
      }
    } else {
      configContents["extends"] = extendsValue;
    }
    if ("root" in configContents) {
      configContents["root"] = false;
    }
    if (customRuleExample) {
      const ruleName = "no-entity-moo";
      const ruleValue = 2;
      if ("rules" in configContents) {
        configContents["rules"][ruleName] = ruleValue;
      } else {
        configContents["rules"] = { [ruleName]: ruleValue };
      }
    }
    await this.writeEslintConfig(configPath, configContents, logger);
    return;
  },

  /**
   * Writes ESLint config contents to file
   * @param {*} configContents config file contents
   * @param {*} configPath config file path to write to
   * @returns {void}
   */
  async writeEslintConfig(configPath, configContents, logger=console) {
    const configType = "recommended";
    const extendsValue = `plugin:@sap/cds/${configType}`;
    let contents = {};
    let configFile = path.basename(configPath);
    let configToAdd = {};
    switch (configFile) {
      case ".eslintrc.js":
      case ".eslintrc.cjs":
        try {
          configContents = await this.readEslintConfig(configPath);
        } catch (err) {
          configContents = {};
        }
        if (configContents && configContents["extends"]) {
          if (
            !configContents["extends"] === extendsValue ||
            !configContents["extends"].includes(extendsValue)
          ) {
            configToAdd["extends"] = extendsValue;
          }
        } else {
          configToAdd["extends"] = extendsValue;
        }
        if (configToAdd["extends"]) {
          logger.log(
            `${term.warn(
              `\n\nPlease add the following to your "${configFile}":\n\nmodule.exports = ${JSON.stringify(configToAdd, null, 2)}`
            )}\n`
          );
        }
        break;
      case ".eslintrc.yaml":
      case ".eslintrc.yml":
        await fsUtil.writeFile(configPath, yaml.stringify(configContents));
        break;
      case ".eslintrc.json":
      case ".eslintrc":
        await fsUtil.writeFile(configPath, `${JSON.stringify(configContents, null, 2)}`);
        break;
      case "package.json":
        if (await fsUtil.pathExists(configPath)) {
          contents = JSON.parse(await fsp.readFile(configPath, "utf8"));
        } else {
          contents = {};
        }
        if (!("eslintConfig" in configContents)) {
          contents["eslintConfig"] = configContents;
        } else {
          contents["eslintConfig"] = [...configContents, ...contents["eslintConfig"]];
        }
        await fsUtil.writeFile(configPath, `${JSON.stringify(contents, null, 2)}`);
        break;
      default:
        break;
    }
    return;
  },

  /**
   * Read VS Code settings from file
   * @param {*} settingsPath settings file path to read from
   * @returns settings file contents
   */
  async readVscodeSettings(settingsPath) {
    let settings;
    if (fsUtil.pathExists(settingsPath)) {
      try {
        settings = await fsUtil.readJSONC(settingsPath);
      } catch (err) {
        settings = {};
      }
    }
    return settings;
  },

  /**
   * Merges two arrays into one
   * @param {*} array input array
   * @param {*} arrayToMerge array to merge with
   * @returns merged array (without duplicates)
   */
  mergeArrays(array, arrayToMerge) {
    let arrayMerged = array.concat(arrayToMerge);
    if (typeof array === "string") {
      array = [array];
    }
    if (typeof arrayToMerge === "string") {
      arrayToMerge = [arrayToMerge];
    }
    arrayMerged = [...new Set([...array, ...arrayToMerge])];
    return arrayMerged;
  },

  /**
   * Add VS Code ESLint extension settings required for CDS linting:
   * (1) Extension file types: [cds, csn]
   * (2) "Custom" case adds rulePaths and removes configFile
   * (3) "Global" case adds configFile and removes rulePaths
   * @param {*} settingsPath VS Code settings file
   */
  async sanitizeVscodeSettings(projectPath, settingsPath, lintType, lintFileTypes, customRuleExample = false) {
    let settings = (await this.readVscodeSettings(settingsPath)) || {};
    const rulePaths = [path.join(".eslint/rules")];

    if (settings["eslint.validate"]) {
      settings["eslint.validate"] = this.mergeArrays(settings["eslint.validate"], lintFileTypes);
    } else {
      settings["eslint.validate"] = lintFileTypes;
    }

    if (lintType === "local") {
      if (settings["eslint.options"]) {
        if (customRuleExample) {
          settings["eslint.options"]["rulePaths"] = rulePaths;
        }
      } else {
        if (customRuleExample) {
          settings["eslint.options"] = {
            rulePaths: rulePaths,
          };
        }
      }
    }

    await this.writeVscodeSettings(settingsPath, settings);
  },

  /**
   * Writes VS Code settings from file
   * @param {*} settings settings file contents
   * @param {*} settingsPath settings file path to write to
   * @returns {void}
   */
  async writeVscodeSettings(settingsPath, settings) {
    if (!settings) {
      await fsUtil.mkdirp(path.dirname(settingsPath));
    }
    await fsUtil.writeJSON(settingsPath, settings);
    return;
  },

  /**
   * Joins or creates prescribed options with that of user
   * - Value for 'config' key will be overwritten if assigned by `cds lint`
   * @param {*} propKey option key property
   * @param {*} propsToAdd option values to add for key property
   * @returns {void}
   */
  mergeWithUserOpts(userOpts, propKey = "", propsToAdd = "") {
    if (propsToAdd) {
      if (Object.keys(userOpts).includes(propKey)) {
        if (!["config", "format"].includes(propKey)) {
          propsToAdd = this.mergeArrays(userOpts[propKey].split(","), propsToAdd.split(",")).join(
            ","
          );
        }
      }
      userOpts[propKey] = propsToAdd;
    } else {
      userOpts[propKey] = true;
    }
    return userOpts;
  },
};
