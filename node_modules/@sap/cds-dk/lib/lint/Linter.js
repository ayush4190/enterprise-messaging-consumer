const os = require("os");
const fs = require("fs");
const commandUtil = require("../init/util/commandUtil");
const path = require("path");
const glob = require("glob");
const term = require("../util/term");

const io = require("./io");
const checks = require("./checks");
const generators = require("./generators");
const {
  getConfigPath,
  getFileExtensions,
} = require("@sap/eslint-plugin-cds/lib/api");

const IS_WIN = os.platform() === "win32";
const ALLOWED_FILE_EXTENSIONS = getFileExtensions();

class Linter {
  constructor() {
    this.eslintCmd = "";
    this.eslintCmdShort = "eslint";
    this.eslintCmdOpts = {};
    this.eslintCmdOptsIndex = 0;
    this.eslintCmdFileExpr = "";
    this.isFile = false;
    this.help = "";
    this.debug = "";
    this.flags = [];
    this.configPath = "";
    this.configGlobalPath = path.join(__dirname, ".eslintrc.js");
    this.configContents = {};
    this.projectPath = "";
    this.cdsdkPath = path.join(__dirname, "../..");
    this.globalPath = path.join(this.cdsdkPath, "../..");
    this.extendsPlugin = false;
    this.pluginPath = "";
    this.lintType = "global";
    this.init = this.init.bind(this);
    this.lint = this.lint.bind(this);
  }

  /**
   * Initializes `cds lint` call and generates the required content
   * object for `cds` executable
   * @returns object continaing help, options, flags and shortcuts
   */
  init(help = "", options = [], flags = [], shortcuts = []) {
    this.eslintCmd = checks.resolveEslint(this.cdsdkPath, this.globalPath);
    if (this.eslintCmd) {
      help = generators.genEslintHelp(this.eslintCmd);
      flags = generators.genEslintFlags(help);
      [help, options, shortcuts, flags] = generators.genEslintShortcutsAndOpts(
        help,
        flags
      );
      this.help = help;
      this.flags = flags;
    } else {
      console.log(
        `${term.error("Cannot call 'eslint -h', install and try again.")}\n`
      );
    }
    return { help, options, flags, shortcuts };
  }

  /**
   * Runner for 'cds lint' which is a wrapper for eslint cmd calls
   * that detecs and adds the required cmd line arguments
   * @param {*} args files/globs for eslint to lint
   * @param {*} options options/flag passed by user
   */
  async lint(args, options) {
    this.eslintCmdOpts = this._sanitizeUserOpts(options);
    this.eslintCmdFileExpr = args.length ? args : ['.']
    if (this.eslintCmdOpts.help) {
      this._printHelp();
    } else {
      // Determine if case "local" or "global" and resolve plugin accordingly
      await this._getConfigFileAndSetProjectPath(args);

      if (this.lintType === "local") {
        await this._addRulePaths();
      }

      if (this.lintType === "global") {
        this._addConfig();
        const overwriteRules = checks.hasEslintConfigContent(
          this.configContents,
          "rules"
        );
        if (overwriteRules) {
          await this._overwriteRuleSeverities();
        }
      }

      // Limit to CDS file extensions
      this._addExtensions();
      // Run ESLint with collected options
      try {
        await this._runEslint();
      } catch (err) {
        term.error(err);
      }
    }
  }

  _printHelp() {
    console.log(
      this.help.replace(
        / \*([^*]+)\*/g,
        ` ${term.codes.bold}$1${term.codes.reset}`
      )
    );
    return;
  }

  _sanitizeUserOpts(options) {
    for (let key in options) {
      let value = options[key];
      if (value && typeof value === "string") {
        value = value.replace(/'/g, "").replace(/"/g, "");
      }
    }
    return options;
  }

  async _addRulePaths() {
    const rulesPath = path.relative(".", ".eslint/rules");
    if (fs.existsSync(rulesPath) && fs.statSync(rulesPath).isDirectory()) {
      this.esllintCmdOpts = io.mergeWithUserOpts(
        this.eslintCmdOpts,
        "rulesdir",
        path.relative(".", rulesPath)
      );
      await generators.genDocs(this.projectPath.replace(rulesPath, ""));
    }
    return;
  }

  _addExtensions() {
    // Add CDS file extensions to lint
    const extensions = ALLOWED_FILE_EXTENSIONS.map((ext) => path.extname(ext));
    this.eslintCmdOpts = io.mergeWithUserOpts(
      this.eslintCmdOpts,
      "ext",
      extensions.join(',')
    );
    // Enable colored output
    this.eslintCmdOpts = io.mergeWithUserOpts(this.eslintCmdOpts, "color");
    return;
  }

  async _runEslint(dryRun = false) {
    const eslintCmdOpts = [];
    // Collect cmd line options
    try {
      for (let key in this.eslintCmdOpts) {
        let value = this.eslintCmdOpts[key];
        if (this.flags.includes(`--${key}`)) {
          eslintCmdOpts.push(`--${key}`);
        } else {
          if (value) {
            eslintCmdOpts.push(`--${key}`);
            // Always quote args which are not paths
            if (!fs.existsSync(value)) {
              eslintCmdOpts.push(`"${value}"`);
              // Paths are quoted according on os
            } else {
              if (IS_WIN) {
                eslintCmdOpts.push(`"${value}"`);
              } else {
                eslintCmdOpts.push(value);
              }
            }
          }
        }
      }
      // Only lint file extensions prescribed by plugin
      eslintCmdOpts.push("--ignore-pattern");
      let ignorePattern = "*.*";
      if (IS_WIN) {
        ignorePattern = `"${ignorePattern}"`;
      } else {
        ignorePattern = `'${ignorePattern}'`;
      }
      eslintCmdOpts.push(ignorePattern);
      ALLOWED_FILE_EXTENSIONS.forEach((ext) => {
        eslintCmdOpts.push("--ignore-pattern");
        ignorePattern = `!${ext}`;
        if (IS_WIN) {
          ignorePattern = `"${ignorePattern}"`;
        } else {
          ignorePattern = `'${ignorePattern}'`;
        }
        eslintCmdOpts.push(ignorePattern);
      });
      let input = "";
      if (IS_WIN) {
        // Braucht es diese unterscheidung wirklich? UnterstÃ¼tzt Windows nicht auch single quotes?
        input = `"${this.eslintCmdFileExpr.join('" "')}"`;
      } else {
        input = `'${this.eslintCmdFileExpr.join("' '")}'`;
      }
      // Run ESLint with given cmd line options
      // - Show 'eslint' instead of actual eslint cmd ('node .../.eslint.js')
      // - Remove debug flag for printed cmd line
      if (this.eslintCmdOpts.debug) {
        eslintCmdOpts.splice(eslintCmdOpts.indexOf('--debug'), 1);
        console.log(
          `Linting:\n ${term.info(`eslint ${eslintCmdOpts.concat(input).join(' ')}`)}\n`
        );
        eslintCmdOpts.push('--debug');
      }
      if (!dryRun) {
        return commandUtil.spawnCommand(this.eslintCmd, eslintCmdOpts.concat(input), {
          cwd: process.cwd(),
          shell: true,
          stdio: process.env.NODE_ENV === 'test' ? 'pipe' : 'inherit',
        });
      } else {
        return Promise.resolve("");
      }
    } catch (err) {
      return Promise.resolve(err);
    }
  }

  _addConfig() {
    this.esllintCmdOpts = io.mergeWithUserOpts(
      this.eslintCmdOpts,
      "config",
      path.relative(".", this.configGlobalPath)
    );
    return;
  }

  async _getConfigFileAndSetProjectPath(args) {
    let input;
    // Only resolve the first input argument
    //
    if (args.length > 0) {
      let stats;
      try {
        stats = fs.statSync(args[0]);
      } catch (err) {
        // Do nothing
      }
      if (
        args[0] === "." ||
        (stats && (stats.isFile() || stats.isDirectory()))
      ) {
        this.isFile = true;
      }
      input = glob.sync(args[0])[0];
    }
    this.configPath = getConfigPath(input);
    if (!this.configPath) {
      this.configPath = this.configGlobalPath;
      this.lintType === "global";
    } else {
      this.configContents = await io.readEslintConfig(this.configPath);
      if (this.configContents) {
        if ("extends" in this.configContents) {
          this.extendsPlugin = checks.hasEslintConfigContent(
            this.configContents,
            "extends"
          );
          if (this.extendsPlugin) {
            this.lintType = "local";
            this.pluginPath = require.resolve("@sap/eslint-plugin-cds", {
              paths: [path.dirname(this.configPath)],
            });
          }
        }
      }
    }
    if (!this.pluginPath) {
      this.pluginPath = require.resolve("@sap/eslint-plugin-cds", {
        paths: [this.cdsdkPath],
      });
    }
    // Project path is directory of ESLint config file
    this.projectPath = path.dirname(this.configPath);
    return;
  }

  async _overwriteRuleSeverities() {
    let configContents = (await io.readEslintConfig(this.configPath)) || {};
    let rules = configContents.rules;
    // Allow recommended plugin rules in cds-dk to be overwritten
    // by user by adding rule to cmd line (because of precedence)
    const pluginRules = require(this.pluginPath).rules;
    if (rules && pluginRules) {
      Object.keys(rules).forEach((rule) => {
        if (Object.keys(pluginRules).includes(rule.replace("@sap/cds/", ""))) {
          this.esllintCmdOpts = io.mergeWithUserOpts(
            this.eslintCmdOpts,
            "rule",
            `${rule}:${rules[rule]}`
          );
        }
      });
    }
    return;
  }
}

module.exports = Linter;
