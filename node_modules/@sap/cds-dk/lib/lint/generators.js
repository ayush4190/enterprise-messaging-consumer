const fs = require("fs");
const os = require("os");
const cp = require("child_process");
const path = require("path");
const { mkdirp } = require("@sap/cds/lib/utils");
const term = require("../util/term");

const IS_WIN = os.platform() === "win32";

const REGEX_FLAGS = /--[a-z,a-z-]+[,\s+]\s+/gm;
const REGEX_OPTIONS = /--[a-z,a-z-]+\s[^\s]/gm;
const REGEX_SHORTCUT_MAPPINGS = /\s-[a-zA-Z]+, --[a-zA-Z-]+/gm;

module.exports = {
  /**
   * Generates `cds lint` help string to print when calling `cds lint [-h, --help]`
   * by getting available options/shortcuts from installed version of ESLint
   * @returns `cds lint` help string
   */
  genEslintHelp: function (eslintCmd) {
    let eslintHelp;
    try {
      eslintHelp = cp
        .execSync(`${eslintCmd} -h`, {
          cwd: process.cwd(),
          shell: IS_WIN,
          stdio: "pipe",
        })
        .toString();
    } catch (err) {
      console.log(
        `${term.error("Cannot call 'eslint -h', install and try again.")}\n`
      );
    }
    let eslintOpts = eslintHelp.split("\n");
    let cdslintCmd = eslintOpts[0].replace("eslint", "*cds lint*");
    eslintOpts[0] = `
        # SYNOPSIS

            ${cdslintCmd} [beta]

            Runs environment checks and/or checks the specified models
            based on the ESLint framework

        # OPTIONS`;
    return `${eslintOpts.join("\n    ")}\n`;
  },

  /**
   * Generates `cds lint` options array by extracting
   * all [--options] and [-shortcuts] strings from help string
   * Shortcut order must match order of [options, flags]
   * Any options without an shortcut must act as filler (undefined)
   * until the shortcuts for the flags start
   * @param help help string and shortcuts array for `cds lint`
   * @param flags help string and shortcuts array for `cds lint`
   * @returns `cds lint` allowed options
   */
  genEslintShortcutsAndOpts: function (help, flags) {
    const allOptions = help
      .match(REGEX_OPTIONS)
      .map((str) => str.split(' ')[0].trim().replace(",", ""));
    const shortcutMappings = help
      .match(REGEX_SHORTCUT_MAPPINGS)
      .map((str) => str.trim().split(/,\s?/));
    let optionsWithShortcuts = [];
    let shortcuts = [];
    let shortcutsForFlags = [];
    shortcutMappings.forEach((m) => {
      if (!flags.includes(m[1])) {
        optionsWithShortcuts.push(m[1]);
        shortcuts.push(m[0]);
      } else {
        const index = flags.indexOf(m[1]);
        flags.splice(index, 1);
        flags.unshift(m[1]);
        shortcutsForFlags.unshift(m[0]);
      }
    });
    const optionsWithoutShortcuts = allOptions.filter((o) => !optionsWithShortcuts.includes(o));
    optionsWithoutShortcuts.forEach((opt) => {
      shortcuts.push(undefined)
    });
    let options = optionsWithShortcuts.concat(optionsWithoutShortcuts);
    shortcuts = shortcuts.concat(shortcutsForFlags);
    return [help, options, shortcuts, flags];
  },

  /**
   * Generates a list of ESLint flags by extracting
   * all [--options] strings from help string which
   * do not require an extra argument
   * @param help string from `cds lint [-h, --help]`
   * @returns ESLint flags
   */
  genEslintFlags: function (help) {
    return help.match(REGEX_FLAGS).map((str) => str.trim().replace(",", ""));
  },

  /**
   * Generates custom rules documentation for user
   * according to contents of rules files
   * @param {*} projectPath
   */
  async genDocs(projectPath) {
    let mdRule, mdRuleSources, mdRuleContents;
    const testPath = path.join(projectPath, ".eslint/tests");
    const rulePath = path.join(projectPath, ".eslint/rules");
    const docsPath = path.join(projectPath, ".eslint/docs");

    if (!fs.existsSync(testPath)) {
      await mkdirp(testPath);
    }
    if (!fs.existsSync(rulePath)) {
      await mkdirp(rulePath);
    }
    if (!fs.existsSync(docsPath)) {
      await mkdirp(docsPath);
    }

    const ruleDocsPath = path.join(docsPath, "Rules.md");
    const ruleListDocsPath = path.join(docsPath, "RuleList.md");
    const ruleDict = {};

    if (!fs.existsSync(ruleDocsPath)) {
      fs.writeFileSync(ruleDocsPath, "", "utf8");
    }
    if (!fs.existsSync(ruleListDocsPath)) {
      fs.writeFileSync(ruleListDocsPath, "", "utf8");
    }

    function getKeyFromMeta(text, key) {
      const regexQuote = new RegExp(`${key}:[\\s]+[\\', \\\`, \\"]`, "gm");
      const matchQuote = regexQuote.exec(text);
      if (matchQuote) {
        const quote = matchQuote[0].slice(-1);
        const exprStart = `${key}:[\\s]+\\${quote}`;
        const exprEnd = `(\\${quote},?)`;
        const regexKey = new RegExp(`${exprStart}[\\s\\S]*?${exprEnd}`, "gm");
        const matchKey = regexKey.exec(text);
        if (matchKey) {
          const regexStart = new RegExp(`${exprStart}`, "gm");
          const regexEnd = new RegExp(`${exprEnd}`, "gm");
          return matchKey[0]
            .replace(regexStart, "")
            .replace(regexEnd, "")
            .replace("fixable:", "")
            .trim();
        } else {
          return "";
        }
      } else {
        return "";
      }
    }

    function getKeyFromTest(text, key) {
      let dissallowPrefix = "";
      if (key === "valid") {
        dissallowPrefix = "[^n]";
      }
      const exprStart = `${dissallowPrefix}${key}:[\\s]+\\[[\\s\\n]+{[\\s\\n]+code:[\\s\\n]+`;
      const regexTestKey = new RegExp(`${exprStart}[\\', \\\`, \\"]`, "gm");
      const matchTestKey = regexTestKey.exec(text);
      if (matchTestKey) {
        const quote = matchTestKey[0].slice(-1);
        const exprStart = `${dissallowPrefix}${key}:[\\s]+\\[[\\s\\n]+{[\\s\\n]+code:[\\s\\n]+`;
        const regexStart = new RegExp(exprStart, "gm");
        const regexCode = new RegExp(
          `${exprStart}${quote}[\\s\\S]*?(\\${quote},?)`,
          "gm"
        );
        const matchCode = regexCode.exec(text);
        const code = matchCode[0].replace(regexStart, "");
        const regex = new RegExp(`${quote},`, "gm");
        const regex2 = new RegExp(`${quote}`, "gm");
        return code.replace(regex, "").replace(regex2, "");
      } else {
        return "";
      }
    }

    function genMdRules(release, table = true) {
      let version = "latest";
      if (release) {
        version = release;
      }
      let mdRules = `# @sap/eslint-plugin-cds [${version}]\n\n`;
      if (table) {
        Object.entries(ruleDict).forEach(([category, rules]) => {
          mdRules += `## Category: ${category}\n\n`;
          mdRules += "<table>";
          mdRules += "<tr><th>Rule</th><th>Fixable</th><th>Version</th></tr>";
          rules.forEach(function (rule) {
            mdRules += `<tr><td><a href="./Rules.md#rule-${rule.name}">${rule.name}</a></td><td>${rule.fix}</td><td>${rule.version}</td></tr>`;
          });
          mdRules += "</table>\n\n<br>\n\n";
        });
      }
      return mdRules;
    }

    const mdRulesCur = fs.readFileSync(ruleDocsPath, "utf8");
    const mdRuleListCur = fs.readFileSync(ruleListDocsPath, "utf8");
    fs.readdirSync(rulePath).filter(function (file) {
      if (path.extname(file).toLowerCase() === ".js") {
        const rule = path.basename(file).replace(path.extname(file), "");
        const ruleTestPath = path.join(testPath, `${rule}.test.js`);

        // Get rule meta information
        const ruleMeta = fs.readFileSync(path.join(rulePath, file), "utf8");
        const details = getKeyFromMeta(ruleMeta, "description");
        const category = getKeyFromMeta(ruleMeta, "category");
        const fixable = getKeyFromMeta(ruleMeta, "fixable");
        let isFixable = "";
        if (["code", "whitespace"].includes(fixable)) {
          isFixable = ":wrench:";
        }
        const version = getKeyFromMeta(ruleMeta, "version");

        // Get rule valid/invalid tests
        mdRule = "";
        if (fs.existsSync(ruleTestPath)) {
          const ruleTest = fs.readFileSync(ruleTestPath, "utf8");
          const valid = getKeyFromTest(ruleTest, "valid");
          const invalid = getKeyFromTest(ruleTest, "invalid");

          mdRule +=
            `<span>:heavy_check_mark:&nbsp;&nbsp; Example of ` +
            `<font style="color:green">correct</font> ` +
            `code for this rule:</span>\n\n\`\`\`\n${valid}\n\`\`\`\n\n`;
          mdRule +=
            `<span>:x:&nbsp;&nbsp; Example of ` +
            `<font style="color:red">incorrect</font> ` +
            `code for this rule:</span>\n\n\`\`\`\n${invalid}\n\`\`\``;
        }

        mdRuleContents = `## Rule: ${rule}\n`;
        mdRuleContents += `<span class='label shifted'>${category}</span>\n\n`;
        mdRuleContents += `### Rule Details\n${details}\n\n`;
        if (mdRule) {
          mdRuleContents += `### Examples\n${mdRule}\n\n`;
        }
        mdRuleContents += `### Version\nThis rule was introduced in \`@sap/eslint-plugin-cds ${version}\`.\n\n`;
        mdRuleSources = `### Resources\n[Rule & Documentation source](${path.relative(
          docsPath,
          path.join(rulePath, `${rule}.js`)
        )})\n\n`;

        if (Object.keys(ruleDict).includes(category)) {
          ruleDict[category].push({
            name: rule,
            fix: isFixable,
            version: version,
            contents: mdRuleContents,
            sources: mdRuleSources,
          });
        } else {
          ruleDict[category] = [
            {
              name: rule,
              fix: isFixable,
              version: version,
              contents: mdRuleContents,
              sources: mdRuleSources,
            },
          ];
        }
      }
    });

    let mdRules = genMdRules(undefined, false);
    let mdRuleList = genMdRules();

    /* eslint-disable-next-line no-unused-vars */
    Object.entries(ruleDict).forEach(([category, rules]) => {
      rules.forEach(function (rule) {
        mdRules += `${rule.contents}\n\n${rule.sources}\n\n---\n\n`;
      });
    });

    if (mdRuleListCur !== mdRuleList || mdRulesCur !== mdRules) {
      fs.writeFileSync(ruleDocsPath, mdRules, "utf8");
      fs.writeFileSync(ruleListDocsPath, mdRuleList, "utf8");
    }
  },
};
