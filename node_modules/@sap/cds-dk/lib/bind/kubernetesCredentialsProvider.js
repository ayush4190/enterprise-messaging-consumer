const cp = require('child_process');
const os = require('os');
const util = require('util');
const yaml = require("@sap/cds-foss")("yaml");

const axios = require('axios');
const { URL } = require('url');

const execFile = util.promisify(cp.execFile);
const IS_WIN = os.platform() === 'win32';

class KubernetesCredentialsProvider {

    constructor() {
        this.logger = console;
    }

    setLogger(logger) {
        this.logger = logger;
    }

    async _kubectlRead(...args) {
        this.logger.debug(`_kubectlRead: kubectl ${args.join(" ")}`);

        const result = await execFile("kubectl", args, {
            shell: IS_WIN,
            stdio: ['inherit', 'pipe', 'inherit'],
        });

        return result.stdout.toString().trim();
    }


    async _kubectlConfig() {
        const configString = await this._kubectlRead('config', 'view', '--raw');
        const config = yaml.parse(configString);

        const currentContextName = config["current-context"];
        if (!currentContextName) throw new Error(`No current context in kubectl config.`);
        const currentContextEntry = config.contexts && config.contexts.find( entry => entry.name === currentContextName && entry.context && entry.context.cluster && entry.context.user );
        if (!currentContextEntry) throw new Error(`Current context not found in kubectl config.`);
        const currentContext = currentContextEntry.context;
        const clusterEntry = config.clusters && config.clusters.find( entry => entry.name === currentContext.cluster && entry.cluster && entry.cluster.server );
        if (!currentContextEntry) throw new Error(`Cluster ${currentContext.cluster} not found in kubectl config.`);
        const cluster = clusterEntry.cluster;
        const userEntry = config.users && config.users.find( entry => entry.name === currentContext.user && entry.user && entry.user.token );
        if (!userEntry) throw new Error(`User ${currentContext.user} not found in kubectl config.`);
        const user = userEntry.user;

        return {
            url: cluster.server,
            namespace: currentContext.namespace || 'default',
            token: user.token
        }
    }

    async init() {
        this.config = await this._kubectlConfig();
    }

    async _req(urlPath) {

        const url = new URL(urlPath, this.config.url);
        this.logger.debug(`_req: ${url.toString()}`);

        const result = await axios.get(url.toString(), {
            validateStatus: status => status === 200 || status === 404,
            headers: {
                authorization: `Bearer ${this.config.token}`
            }
        });

        if (result.status === 200) {
            return result.data;
        } else {
            return null
        }
    }


    async resolve(name, binding) {
        if (!this.initPromise) {
            this.initPromise = this.init();
        }
        await this.initPromise;

        let {cluster, namespace, name: bindingName, secret } = binding;
        let instance;
        let secretOrBindingResource = 'Secret';

        if (!namespace) namespace = this.config.namespace;
        if (cluster && cluster !== this.config.url) throw new Error(`Current Kubernetes cluster "${this.config.url}" different than Kubernetes cluster "${cluster}" for service binding "${name}".`);

        if (bindingName) {
            const bindingResource = await this._req(`/apis/servicecatalog.k8s.io/v1beta1/namespaces/${encodeURIComponent(namespace)}/servicebindings/${encodeURIComponent(bindingName)}`);
            if (bindingResource === null) {
                // Fallback to secret instead of service binding;
                secret = bindingName;
                bindingName = undefined;
                secretOrBindingResource = 'Service Binding or Secret';
            } else {
                secret = bindingResource.spec.secretName || throwError();
                instance = bindingResource.spec.instanceRef && bindingResource.spec.instanceRef.name || throwError();
            }
        }

        const secretResource = await this._req(`/api/v1/namespaces/${encodeURIComponent(namespace)}/secrets/${encodeURIComponent(secret)}`);
        if (secretResource === null) throwError(`${secretOrBindingResource} '${secret}' not found.`);

        const credentials = {};
        for (const name in secretResource.data) {
            let value = secretResource.data[name];
            value = Buffer.from(value, "base64").toString(); // secret values are base64 encoded
            // TODO: TESTIT
            if (value && value[0] === '{') try { value = JSON.parse(value); } catch(e) {/* ignored */} // secret values may contain JSON objects
            credentials[name] = value;
        }

        const resolvedBinding = {
            binding: {
                type: "k8s",
                name: bindingName,
                cluster: this.config.url,
                instance,
                namespace,
                secret: secret,
                resolved: true,
            },
            credentials
        };


        if (instance) {
            const serviceInstanceResource = await this._req(`/apis/servicecatalog.k8s.io/v1beta1/namespaces/${encodeURIComponent(namespace)}/serviceinstances/${encodeURIComponent(instance)}`);

            resolvedBinding.binding.vcap = {
                label: serviceInstanceResource.spec.clusterServiceClassExternalName,
                plan: serviceInstanceResource.spec.clusterServicePlanExternalName
            }
        }

        return resolvedBinding;
    }

}


/**
 *
 * @param {string} msg
 * @returns {never}
 */
function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}

module.exports = new KubernetesCredentialsProvider();
