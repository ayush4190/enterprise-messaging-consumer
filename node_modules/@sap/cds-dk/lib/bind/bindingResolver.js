const Config = require('@sap/cds/lib/env')
const cds = require('@sap/cds/lib');
const LOG = cds.log('bind');
const resolveBinding = resolver(LOG);
const { platformText, bindingText } = require('./bindingUtil');

function getUnresolvedBindings({cwd = process.cwd(), env}) {
    if (!env) env = Config.for('cds', cwd)
    if (feature(env) === false || feature(env) === "false") return {}

    const requires = env.requires || {}
    let bindings = {}
    for (const name in requires) {
        const service = requires[name]
        if (service && service.binding && !service.binding.resolved) {
            bindings[name] = {...service.binding, kind: service.kind }
        }
    }

    return bindings
}

async function resolveBindings({bindings, cwd = process.cwd(), env, output = 'info', cache = {} }) {
    const config = { requires: { } }
    bindings = bindings || getUnresolvedBindings({cwd, env})
    if (Object.keys(bindings).length===0) return config;
    LOG[output](`resolving cloud service bindings...`)
    await Promise.all( Object.keys(bindings).map( async name => {
        const binding = bindings[name]
        const cacheKey = JSON.stringify(binding)
        if (!cache[cacheKey]) {
            cache[cacheKey] = config.requires[name] = await resolveBinding(name, binding)
            LOG[output](`bound ${name} to ${platformText(binding)} ${bindingText(binding)}`)
        } else {
            config.requires[name] = cache[cacheKey]
        }
    } ));

    // Add kind to result, so that it can be applied to old @sap/cds versions that do not read `.cdsrc-private.json`
    for (const name in config.requires) {
        if (bindings[name].kind) config.requires[name].kind = bindings[name].kind
    }

    return config
}

let cfKeyProvider
let kubernetesCredentialsProvider

function resolver(log) {
    return function resolveBinding(name, binding) {
        switch (binding.type) {
            case 'cf':
                if (!cfKeyProvider) {
                    cfKeyProvider = require('./cfKeyProvider');
                    cfKeyProvider.setLogger(log);
                }
                return cfKeyProvider.resolve(name, binding)
            case 'k8s':
                if (!kubernetesCredentialsProvider) {
                    kubernetesCredentialsProvider = require('./kubernetesCredentialsProvider')
                    kubernetesCredentialsProvider.setLogger(log)
                }
                return kubernetesCredentialsProvider.resolve(name, binding)
            default:
                throw new Error(`Unsupported binding type "${binding.type}" for service "${name}".`)
        }
    }
}

async function applyTo(options) {
    const config = await resolveBindings(options)
    if (!config) return
    const {env} = options
    for (const name in config.requires) {
        const service = config.requires[name]
        const { binding, credentials } = service
        Object.assign(env.requires[name], { binding, credentials })
    }

    if (env._emulate_vcap_services) {
        env._emulate_vcap_services()
    }
}

class BindingManager {
    constructor(options) {
        this.cache = {}
        this.bindingsStr = ''
        this.options = options
    }

    getBindings() {
        const bindings = getUnresolvedBindings(this.options)
        return bindings
    }

    async resolve(bindings) {
        if (!bindings) {
            bindings = this.getBindings(this.options)
            this.bindingsStr = JSON.stringify(bindings)
        }

        const config = await resolveBindings({...this.options, bindings, cache: this.cache})
        if (config && Object.keys(config.requires || {}).length > 0) return config;
    }

    async update({ onBeforeUpdate, onAfterUpdate } = {}) {
        const oldBindingsStr = this.bindingsStr
        const bindings = this.getBindings()
        const bindingsStr = JSON.stringify(bindings)
        this.bindingsStr = bindingsStr

        if (this.bindingsStr === oldBindingsStr) return // No change
        if (onBeforeUpdate) await onBeforeUpdate()

        try {
            if (this.pendingUpdate) await this.pendingUpdate
        } catch(error) {
            // ignore
        }
        this.pendingUpdate = undefined

        if (this.bindingsStr !== bindingsStr) return // Next update in progress

        let resolvedBindings
        try {
            this.pendingUpdate = this.resolve(bindings)
            resolvedBindings = await this.pendingUpdate
        } catch(error) {
            LOG.error(error.message)
            return
        }

        if (this.bindingsStr !== bindingsStr) return // Next update in progress
        if (onAfterUpdate) onAfterUpdate(resolvedBindings)
    }
}

function feature(env) {
    return env.features && env.features.dk && env.features.dk.resolveBindingsForTesting
}

module.exports = {
    resolver,
    applyTo,
    bindingManager: function(options) {
        return new BindingManager(options)
    }
}
