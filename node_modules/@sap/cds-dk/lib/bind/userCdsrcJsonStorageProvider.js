const os = require('os');
const path = require('path');
const readline = require('readline');

// TODO transition to fs â†’ need to mock fs and fse in test (cf. MTX client)
const { fse } = require('@sap/cds-foss');
const { highlight } = require('../util/term');

const commandUtil = require('../init/util/commandUtil');

const CDSRC_FILENAME = '.cdsrc-private.json';
const GIT_IGNORE_FILE = '.gitignore';

class UserCdsrcJsonStorageProvider {

    async askBooleanQuestion(question) {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        question = question.trim() + ' ';
        return new Promise(resolve => {
            rl.question(question, answer => {
                if (answer === 'y' || answer === 'Y') {
                    resolve(true);
                } else {
                    resolve(false);
                }
                rl.close();
            });
        });
    }

    async ensureFileIsGitignored(file, logger = console) {
        try {
            await commandUtil.spawnCommand('git', ['check-ignore', '-n', '-v', file], {}, undefined, true);
            return; // file is git ignored
        } catch (err) {
            if (err.code === 'ENOENT') {   // git command not found
                logger.debug('git command not found');
                return;
            }

            if (!err.stdLog.match(/::/)) {   // included or not a git repo
                logger.debug(err);
                return;
            }
        }

        logger.log(`adding entry '${file}' to ${GIT_IGNORE_FILE}.`);
        let gitignore = await this.readFileSafely(GIT_IGNORE_FILE);
        gitignore = gitignore + `
# added by cds bind
${file}
`;
        await fse.writeFile(GIT_IGNORE_FILE, gitignore, 'utf8');
    }

    async readFileSafely(file) {
        try {
            return await fse.readFile(file, 'utf8');
        } catch (err) {
            return '';
        }
    }

    async storeServices(services, options = {}) {
        let jsonPath = options['output-file'] || CDSRC_FILENAME;

        if (jsonPath === CDSRC_FILENAME) {
            await this.ensureFileIsGitignored(CDSRC_FILENAME, options.logger);
        }

        jsonPath = jsonPath.replace(/~/g, os.homedir());
        // const stat = await fse.stat(jsonPath);
        if (path.extname(jsonPath) !== '.json') {
            jsonPath = path.join(jsonPath, '.cdsrc.json');
        }

        // if (options['save-credentials'] && services.find(service => service.credentials) && process.stdin.isTTY) {
        //     const answer = await this.askBooleanQuestion(warn(`IF YOU CONTINUE, SENSITIVE DATA WILL BE WRITTEN TO AN UNENCRYPTED FILE [${jsonPath}]! Do you want to continue [y/N] ?`));
        //     if (!answer) {
        //         options.logger.log(`aborting cds bind; not writing any sensitive data to file [${jsonPath}]`);
        //         return;
        //     }
        // }

        const jsonObject = await this.readJsonSafely(jsonPath);
        let cdsRoot;
        if (path.basename(jsonPath) === 'package.json') {
            jsonObject.cds = jsonObject.cds || {};
            cdsRoot = jsonObject.cds;
        } else {
            cdsRoot = jsonObject;
        }

        const profileKey = `[${options.profile}]`;
        cdsRoot.features = cdsRoot.features || {};
        cdsRoot.features[profileKey] = cdsRoot.features[profileKey] || {};
        cdsRoot.features[profileKey].emulate_vcap_services = true;

        cdsRoot.requires = cdsRoot.requires || {};
        let section;
        if (options.profile) {
            section = cdsRoot.requires[profileKey] = cdsRoot.requires[profileKey] || {};
        } else {
            section = cdsRoot.requires;
        }

        for (const service of services) {
            const { name, kind, binding, credentials, vcap } = service;
            const requireService = section[name] = section[name] || {};

            Object.assign(requireService, { binding, credentials });
            if (kind) requireService.kind = kind;
            if (vcap) requireService.vcap = vcap;
        }

        await this.writeJsonFile(jsonPath, jsonObject, options.logger);
        if (options.profile) {
            options.logger.log(`Saving bindings to ${highlight(jsonPath)} in profile ${highlight(options.profile)}`);
        } else {
            options.logger.log(`Saving bindings to ${highlight(jsonPath)}`);
        }
    }

    async readJsonSafely(filePath) {
        try {
            return await fse.readJSON(filePath) || {};
        } catch (err) {
            return {};
        }
    }

    async writeJsonFile(filePath, content) {
        await fse.outputJSON(filePath, content, {
            spaces: 2
        });

        await fse.chmod(filePath, 0o600); // -rw-------
    }
}

module.exports = new UserCdsrcJsonStorageProvider();
