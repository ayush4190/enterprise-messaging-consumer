const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');

const AuthManager = require('./auth_manager');
const BaseCommand = require('./base_command');
const { collectFileContent, collectFiles, toUnixPath } = require('./helper/fs_helper');
const Logger = require('./helper/logging');

const COMMAND_URL_SUFFIX = 'asyncActivate';
const COMMAND_URL_SUFFIX_SYNC = 'activate';
const UPDATE_CUSTOM_FILE_URL_SUFFIX = 'updateCustomTenantContent';

const I18N_WHITELIST = ['.properties', '.csv'];

const JOB_STATUS = {
    QUEUED: 'QUEUED',
    RUNNING: 'RUNNING',
    FINISHED: 'FINISHED',
    FAILED: 'FAILED'
};

async function checkFinished(jobId, statusUrl, params, finisher) {
    const { status, error } = (await axios.get(statusUrl, params.get('reqAuth'))).data;

    if ((status === JOB_STATUS.FINISHED || status === JOB_STATUS.FAILED) && !finisher.finished) {
        finisher.finished = true;
        clearInterval(finisher.timer);
        if (status === JOB_STATUS.FAILED) {
            return finisher.reject(new Error(`Job ${jobId} failed: ${error.message || JSON.stringify(error)}`));
        }
        Logger.log('Extension active');
        finisher.resolve();
    }
}

module.exports = class Activate extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }
    static get COMMAND_URL_SUFFIX_SYNC() { return COMMAND_URL_SUFFIX_SYNC; }
    static get UPDATE_CUSTOM_FILE_URL_SUFFIX() { return UPDATE_CUSTOM_FILE_URL_SUFFIX; }

    static async run(injection, paramValues) {
        try {
            const params = await AuthManager.loginAndUpdateSettings(paramValues);

            if (process.env.DEBUG) {
                Logger.log('Activating extension with parameters ' + JSON.stringify({
                    appUrl: params.get('appUrl'),
                    projectFolder: params.get('projectFolder'),
                    undeploy: params.get('undeploy'),
                    sync: params.get('sync')
                }));
            } else {
                Logger.log(`Activating extension located at ${params.get('projectFolder')} to URL ${params.get('appUrl')}`);
            }

            if (!await Activate.checkProject(params.get('projectFolder'))) {
                throw new Error(params.get('projectFolder') + ' is not a valid extension project');
            }

            try {
                await Activate.runActivate(injection.cds, params);
                if (params.get('wsdl')) {
                    await Activate.runCustomFileUpload(params);
                }
            } catch (error) {
                Activate.handleHttpError(error, params);
            }
        } catch (error) {
            Logger.error(undefined, error);
        }
    }

    static async collectExtensionFiles(cds, projectFolder) {

        const absoluteFolder = projectFolder;
        const dbFolder = path.join(absoluteFolder, 'db');
        const srvFolder = path.join(absoluteFolder, 'srv');

        const resolvedPathDb = cds.resolve(dbFolder, { root: dbFolder });
        const resolvedPathSrv = cds.resolve(srvFolder, { root: srvFolder });

        let resolvedPaths = [];
        if (resolvedPathSrv) {
            resolvedPaths = resolvedPaths.concat(resolvedPathSrv);
        }

        if (resolvedPathDb) {
            resolvedPaths = resolvedPaths.concat(resolvedPathDb);
        }

        let allFiles = new Map();

        if (resolvedPaths.length < 1) {
            Logger.log('No extension files found');
            return allFiles;
        }

        const csn = await cds.load(resolvedPaths);
        const sources = csn.$sources || csn._sources;

        const filteredSources = sources && sources.filter((entry) => {
            if (! entry.startsWith(projectFolder)) {
                /* Current file might be below the base model's node_modules, in which case compilation on server should succeed.
                   Otherwise, compilation will probably fail, with this message giving a hint. */
                Logger.debug(`Source file outside project folder will not be uploaded: ${entry}`);
                return false;
            }
            const unixFilename = toUnixPath(entry);
            return !/.*node_modules\/_base\/.*/.test(unixFilename);
        }) || [];

        const sourceFiles = await collectFileContent(filteredSources, projectFolder);
        allFiles = new Map([...allFiles, ...sourceFiles]);

        const modelFiles4I18n = { $sources: filteredSources };

        let i18nFolders = cds.localize.folders4(modelFiles4I18n);
        i18nFolders = i18nFolders.filter(i18nFolder => {
            const unixFilename = toUnixPath(i18nFolder);
            return !(/.*node_modules\/_base\/.*/.test(unixFilename));
        });

        // FIXME remove async
        i18nFolders.forEach(async(folder) => {
            const i18nFiles = collectFiles(projectFolder, folder, entry => {
                const ext = path.extname(entry);
                return I18N_WHITELIST.includes(ext);
            });
            allFiles = new Map([...allFiles, ...i18nFiles]);
        });

        try {
            const pkgJson = await fs.readFile(path.join(absoluteFolder, 'package.json'), 'utf-8');
            allFiles.set('package.json', pkgJson);
        } catch(e) {
            Logger.log('No package.json file found');
            Logger.error('No package.json file found', e);
        }

        return allFiles;
    }

    static collectCustomFiles(projectFolder) {
        const wsdlFolder = path.join(projectFolder, 'wsdl');

        try {
            const wsdlFiles = collectFiles(projectFolder, wsdlFolder);
            if (wsdlFiles.size === 0) {
                Logger.log('No custom files found');
            }
            return wsdlFiles;
        } catch (error) {
            Logger.error(undefined, error);
            throw new Error('No custom files found');
        }
    }

    static async runActivate(cds, params) {
        let activationUrl;
        const isSync = params.get('sync');

        return Activate.collectExtensionFiles(cds, params.get('projectFolder'))
        .then(allFiles => {
            if (allFiles.size === 0) {
                return null;
            }

            Logger.log('Activating extension...');

            const urlSuffix = isSync ? Activate.COMMAND_URL_SUFFIX_SYNC : Activate.COMMAND_URL_SUFFIX;
            activationUrl = Activate.getMtxApiUrl(params.get('appUrl'), urlSuffix);
            const requestOptions = Object.assign({
                headers: {}
            }, params.get('reqAuth'));
            requestOptions.headers['Content-Type'] = 'application/json';

            return axios.post(activationUrl, {
                extension: [...allFiles],
                undeployExtension: params.get('undeploy')
            }, requestOptions);
        })
        .then(response => {
            if (isSync || response === null) {
                return;
            }

            const { jobID: jobId, statusPath } = response.data;

            if (jobId === undefined) {
                throw new Error('Activation failed: did not receive job ID');
            }

            if (!statusPath) {
                throw new Error(`Job ${jobId} failed: did not receive job-status path`);
            }

            Logger.debug(`Job ID: ${jobId}`);

            return new Promise((resolve, reject) => {
                const statusUrl = Activate.concatUrls(params.get('appUrl'), statusPath);
                const finisher = {
                    resolve,
                    reject,
                    finished: false,
                    timer: null
                };
                finisher.timer = setInterval(checkFinished.bind(undefined, jobId, statusUrl, params, finisher), 250);
            });
        });
    }

    static async runCustomFileUpload(params) {
        Logger.log(`Uploading custom files to ${params.get('appUrl')}...`);

        const customFiles = Activate.collectCustomFiles(params.get('projectFolder'));

        const customFilesSerialized = [];
        customFiles.forEach((value, key) => {
            customFilesSerialized.push({
                category: "wsdl",
                name: key,
                content: value
            });
        });

        const customFileUrl = Activate.getMtxApiUrl(params.get('appUrl'), Activate.UPDATE_CUSTOM_FILE_URL_SUFFIX);
        const requestOptions = Object.assign({
            headers: {},
        }, params.get('reqAuth'));
        requestOptions.headers['Content-Type'] = 'application/json';

        await axios.post(customFileUrl, {
            content: customFilesSerialized
        }, requestOptions);

        Logger.log('Custom file upload finished');
    }

}
