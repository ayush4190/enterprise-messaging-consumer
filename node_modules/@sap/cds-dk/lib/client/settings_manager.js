const fs = require('fs');
const os = require('os');
const path = require('path');
const { fse } = require('@sap/cds-foss');

const requireGlobal = require('./helper/dependency_helper');
const keytar = requireGlobal('keytar');

const { getAppFromSuggestions, getAppName, getSubdomain } = require('./helper/cf_helper');
const isBas = require('./helper/env_helper');
const Logger = require('./helper/logging');
const Question = require('./helper/question');
const { defaultSchema, extractSubdomain, schemaRegex } = require('./helper/url_helper');
const { ParamCollection, Persistence } = require('./params');

const CONFIG_SUBDIRS = {
    linux: '.config',
    darwin: path.join('Library', 'Preferences'),
    win32: 'AppData'
}

const TOKEN_STORAGE_DESC = {
    plain: 'plain-text storage',
    keyring: 'keyring'
}

const KEYRING_DESC = {
    linux: 'libsecret',
    darwin: 'Keychain',
    win32: 'Credential Vault'
}

const MTX_FULLY_QUALIFIED = 'com.sap.cds.mtx';
const OAUTH_PATH = '/mtx/v1/oauth/token';

const SETTINGS_DIR = path.join(os.homedir(), CONFIG_SUBDIRS[os.platform()] || '', MTX_FULLY_QUALIFIED);
const SETTINGS_FILE = 'projects.json';
const AUTH_FILE = 'auth.json';

const CONFIG = {
    paths: {
        settings: path.join(SETTINGS_DIR, SETTINGS_FILE),
        auth: path.join(SETTINGS_DIR, AUTH_FILE)
    },
    keyringDesignation: KEYRING_DESC[os.platform()] || 'not supported'
};

function other(tokenStorage) {
    if (!tokenStorage) {
        return tokenStorage;
    }
    return tokenStorage === 'plain'
           ? 'keyring'
           : 'plain';
}

function getProjectFolder(params) {
    if (params.has('projectFolder')) {
        const maybeExistentPath = path.resolve(params.get('projectFolder'));
        return maybeExistentPath;
    }
    const existentPath = params.has('subdomain') && fs.existsSync(params.get('subdomain'))
        ? params.get('subdomain')
        : '.';
    return fs.realpathSync(existentPath);
}

async function getAppUrlAndSubdomainFromSuggestions(params) {
    const app = await getAppFromSuggestions();
    if (!app) {
        return;
    }

    params.set('appUrl', app.url);

    if (!params.has('subdomain')) {
        params.set('subdomain', await getSubdomainFromCfAndNotify(app.name));
    }
}

async function getSubdomainFromCfAndNotify(appName) {
    const subdomain = await getSubdomain(appName);
    if (subdomain) {
        Logger.log(`Subdomain determined from CF app environment: ${subdomain}`);
    } else {
        Logger.log('Failed to determine subdomain from CF app environment');
    }
    return subdomain;
}

function getTokenBaseUrl(params, renewUrl) {
    if (params.has('tokenUrl') && !renewUrl) {
        return params.get('tokenUrl');
    }
    if (!params.has('appUrl')) {
        throw new Error('Failed to determine token URL: app URL not given');
    }
    const baseUrl = new URL(params.get('appUrl'));
    baseUrl.pathname = baseUrl.pathname.replace(/\/?$/, OAUTH_PATH);
    return baseUrl.toString();
}

function getKeyringAccountName(params) {
    return `${params.get('appUrl')}|${params.get('subdomain')}`;
}


function logConfigPaths() {
    Logger.debug(`Settings are stored in ${CONFIG.paths.settings}`);
    Logger.debug(`Authentication data is stored in ${CONFIG.paths.auth} or keyring ('${CONFIG.keyringDesignation}' on this platform)`);
}

function notifyLoggedIn(params) {
    return params.get('renewLogin')
           ? Logger.log.bind(Logger)
           : Logger.debug.bind(Logger);
}

function emptyData(all) {
    return all ? {} : new ParamCollection();
}

class SettingsManager {

    static init() {
        logConfigPaths();
    }

    static get config() {
        return CONFIG;
    }

    // Call with 'projectFolder' param as a resolved path.
    static async saveSettings(params) {
        Logger.debug(`Saving settings for project ${params.get('projectFolder')}`);
        if (params.has('token') && ! params.has('tokenStorage')) {
            Logger.log('Note: the authentication token is not saved by default. To save the token for later commands, please run `cds login`.');
        }

        await this._saveToFile(params.get('projectFolder'), params.toValueMap(Persistence.setting));

        if (!params.has('token')) {
            return;
        }

        if (params.get('clearOtherTokenStorage')) {
            // Delete token from the other storage.
            params.delete('clearOtherTokenStorage');
            await this.deleteToken(params, true);
        }

        if (params.get('tokenStorage') === 'plain') {
            await this._saveAuthToFile(params, params.toValueMap(Persistence.auth));
        } else if (params.get('tokenStorage') === 'keyring') {
            await this._saveAuthToKeyring(params, params.toValueMap(Persistence.auth));
        }
    }

    static async loadAndMergeSettings(params, logout = false) {
        const projectFolder = getProjectFolder(params);
        params.set('projectFolder', projectFolder);

        Logger.debug(`Loading settings for project ${projectFolder}`);
        const loadedSettings = await this._loadFromFile(projectFolder);
        Logger.debug(`Loaded project settings: ${loadedSettings.format()}`);

        params.mergeLower(loadedSettings);

        await this.updateUrls(params, logout);
        await this.checkKeytar(params, logout);
        await this.addAuth(params, logout);
        Logger.debug(`Effective project settings: ${params.format()}`);
    }

    static async updateUrls(params, logout) {
        async function addAppUrlAndSubdomain() {
            if (params.has('appUrl') && !schemaRegex.test(params.get('appUrl'))) {
                params.set('appUrl', defaultSchema + params.get('appUrl'));
                Logger.debug(`Added schema to app URL: ${params.get('appUrl')}`);
            }
            if (!logout) {
                if (!params.has('appUrl')) {
                    Logger.debug('App URL not given');
                    await getAppUrlAndSubdomainFromSuggestions(params);
                } else if (!params.has('subdomain')) {
                    Logger.debug('Subdomain not given');
                    const appName = await getAppName(params.get('appUrl'));
                    if (appName) {
                        params.set('subdomain', await getSubdomainFromCfAndNotify(appName));
                    }
                }
            }
            if (!params.has('appUrl')) {
                throw new Error('App URL not given. Please specify it or log in to Cloud Foundry and repeat this command.');
            }
            if (!params.has('subdomain')) {
                params.set('subdomain', extractSubdomain(params.get('appUrl')));
                if (!params.has('subdomain')) {
                    throw new Error('Subdomain not given');
                }
                Logger.log(`Subdomain determined from app URL: ${params.get('subdomain')}`);
            }
        }
        function renewTokenUrl() {
            const renewUrl = params.get('appUrl') !== params.get('appUrl');
            if (!params.get('tokenUrl') || renewUrl) {
                params.set('tokenUrl', getTokenBaseUrl(params, renewUrl));
            }
        }

        await addAppUrlAndSubdomain();

        if (!logout) {
            renewTokenUrl();
        }
    }

    static async checkKeytar(params, logout) {
        if (isBas()) {
            if (params.get('tokenStorage') === 'keyring') {
                Logger.log(`NOTE: Keyring storage not supported on SAP Business Application Studio. Switching to plain-text storage.`);
                params.set('tokenStorage', 'plain');
            }
            return;
        }
        if (params.get('username') || keytar) {
            return;
        }
        if (params.get('tokenStorage') === 'keyring') {
            throw new Error('Keyring storage requested but keytar not installed. Please run `npm install -g keytar` or ' +
                'switch to plain-text storage by adding `--plain` (discouraged).');
        }
        if (params.get('renewLogin') || logout) {
            Logger.log('Disabling keyring functionality: \'keytar\' module not found. Run `npm install -g keytar` to install it.');
        }
    }

    static async addAuth(params, logout) {
        async function addPassword() {
            params.set('password', await Question.askQuestion('Password: ', undefined, true));
            if (params.get('password') === '') {
                throw new Error('Password cannot be empty');
            }
        }
        async function addClientSecret() {
            params.set('clientsecret', await Question.askQuestion('clientsecret: ', undefined, true));
            if (params.get('clientsecret') === '') {
                throw new Error('clientsecret cannot be empty');
            }
        }
        async function addPasscode() {
            const prompt = `Passcode${params.get('passcodeUrl') ? ' (visit ' + params.get('passcodeUrl') + ' to generate)' : ''}: `;
            params.set('passcode', await Question.askQuestion(prompt, undefined, true));
            console.log(); // DON'T: process.stdout.write('\n');
            if (params.get('passcode') === '') {
                throw new Error('Passcode cannot be empty');
            }
        }
        function setRelevantAuth(auth) {
            if (!(auth.keyring.has('tokenStorage') || auth.plain.has('tokenStorage'))) {
                // Saved auth data not present.
                return;
            }
            let storage = params.get('tokenStorage');
            if (auth.keyring.has('tokenStorage') && auth.plain.has('tokenStorage')) {
                // Both storage places contain data: retrieve from selected or keyring.
                storage = storage || 'keyring';
                Logger.debug('WARNING: authentication data found in both kinds of storage. ' +
                    `Using data from ${TOKEN_STORAGE_DESC[storage]}; other storage will be cleared when next saving.`);

                params.merge(auth[storage]);
                params.set('clearOtherTokenStorage', true);

            } else if (storage && auth[other(storage)].has('tokenStorage')) {
                // Selected storage contains no data, but other one does: retrieve from other storage, but earmark migration to selected one.
                Logger.debug(`Using authentication data from ${TOKEN_STORAGE_DESC[other(storage)]}; will be migrated to other storage on save.`);

                params.merge(auth[other(storage)]);
                params.set('tokenStorage', storage);
                params.set('clearOtherTokenStorage', true);

            } else {
                // One storage contains data, and there's no conflict with selection.
                const storage = auth.keyring.get('tokenStorage') || auth.plain.get('tokenStorage');
                Logger.debug(`Using authentication data from ${TOKEN_STORAGE_DESC[storage]}.`);

                params.merge(auth[storage]);
            }
        }

        Logger.debug(`Consolidating authentication data for project ${params.get('projectFolder')}`);

        if (params.has('username')) {
            if (!params.get('password') && !logout) {
                await addPassword();
            }
            return;
        }

        if (params.get('clientid') && !params.get('clientsecret') && !logout) {
            await addClientSecret();
        }

        const auth = {
            plain: await this._loadAuthFromFile(params.get('appUrl'), params.get('subdomain')),
            keyring: await this._loadAuthFromKeyring(params.get('appUrl'), params.get('subdomain'))
        };

        setRelevantAuth(auth);

        if (!params.has('token') && !params.has('passcode') && !logout) {
            await addPasscode();
        }
    }

    static async deleteToken(params, fromOtherStorage = false) {
        const allParams = params.clone();
        await this.loadAndMergeSettings(allParams, true);

        const target = `URL ${allParams.get('appUrl')}, subdomain '${allParams.get('subdomain')}'`;
        let fromStorage = fromOtherStorage && other(params.get('tokenStorage'))
        const deleteBoth = !fromStorage && allParams.get('tokenStorage') && allParams.get('clearOtherTokenStorage');

        Logger.debug(`Deleting authentication data${fromOtherStorage ? ' from other storage' : ''} for ${target}`);

        fromStorage = fromStorage || allParams.get('tokenStorage');
        if (!fromStorage) {
            Logger.log(`No authentication data found for ${target}`);
            return;
        }

        if (fromStorage === 'plain' || deleteBoth) {
            await this._saveAuthToFile(allParams, null);
        }
        if (fromStorage === 'keyring' || deleteBoth) {
            await this._saveAuthToKeyring(allParams, null);
        }
    }

    static async deleteSettingsWithoutToken(params) {
        const projectFolder = getProjectFolder(params);
        Logger.debug(`Deleting settings for project ${projectFolder}`);
        await this._saveToFile(projectFolder, null);
    }

    static async deleteInvalid() {
        Logger.log('Deleting invalid project settings');

        const settingsByFolder = await this._loadFromFile(undefined);
        const deletionFolders = [];
        const deletionUrlsAndSubdomains = new Set();

        Object.entries(settingsByFolder)
            .filter(entry => ! fs.existsSync(entry[0]))
            .forEach(entry => {
                delete settingsByFolder[entry[0]];
                deletionFolders.push(entry[0]);
                deletionUrlsAndSubdomains.add(entry[1].appUrl + '|' + entry[1].subdomain);
            });

        await this._saveAllSettingsToFile(settingsByFolder);

        if (deletionFolders.length) {
            for (const urlAndSubdomain of deletionUrlsAndSubdomains.values()) {
                const appUrl = urlAndSubdomain.replace(/\|.*/, '');
                const subdomain = urlAndSubdomain.replace(/.*\|/, '');
                const urlReference = Object.values(settingsByFolder).find(settings => settings.appUrl === appUrl && settings.subdomain === subdomain);
                if (!urlReference) {
                    await this.deleteToken(new ParamCollection({ appUrl, subdomain }));
                }
            }
            Logger.log(`Deleted settings for nonexistent project folders:${deletionFolders.map(folder => ' ' + folder)}`);
        } else {
            Logger.log('All settings seem valid');
        }
    }

    static async _saveToFile(projectFolder, paramValues) {
        const paramValuesByFolder = await this._loadFromFile(undefined);
        if (paramValues !== null) {
            paramValuesByFolder[projectFolder] = paramValues;
            await this._saveAllSettingsToFile(paramValuesByFolder);
            Logger.debug(`Saved project settings: ${JSON.stringify(paramValues)}`);
        } else {
            delete paramValuesByFolder[projectFolder];
            await this._saveAllSettingsToFile(paramValuesByFolder);
            Logger.log('Deleted project settings');
        }
    }

    static async _saveAllSettingsToFile(paramValuesByFolder) {
        Logger.debug(`Saving all settings to ${CONFIG.paths.settings}`);
        await fse.outputJson(CONFIG.paths.settings, paramValuesByFolder, { spaces: 2 });
        Logger.debug('Saved settings');
    }

    static async _saveAuthToFile(params, authValues) {
        Logger.debug(`Updating authentication data to ${CONFIG.paths.auth}`);
        const appUrl = params.get('appUrl');
        const location = `plain-text storage for app URL ${appUrl}, subdomain ${params.get('subdomain')}`;

        const allAuthValues = await this._loadAuthFromFile(undefined, undefined);
        if (authValues !== null) {
            (allAuthValues[appUrl] || (allAuthValues[appUrl] = {}))[params.get('subdomain')] = authValues;
            await fse.outputJson(CONFIG.paths.auth, allAuthValues, { spaces: 2 });
            notifyLoggedIn(params)(`Saved authentication data to ${location}`);
        } else if (allAuthValues[appUrl]) {
            delete allAuthValues[appUrl][params.get('subdomain')];
            if (Object.keys(allAuthValues[appUrl]).length === 0) {
                delete allAuthValues[appUrl];
            }
            await fse.outputJson(CONFIG.paths.auth, allAuthValues, { spaces: 2 });
            Logger.log(`Deleted authentication data from ${location}`);
        } else {
            Logger.log(`No authentication data to delete from ${location}`);
        }
    }

    static async _saveAuthToKeyring(params, auth) {
        if (!keytar) {
            return;
        }

        Logger.debug('Updating authentication data to keyring');
        const location = `keyring for app URL ${params.get('appUrl')}, subdomain ${params.get('subdomain')}`;

        if (auth !== null) {
            await keytar.setPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(params), JSON.stringify(auth));
            notifyLoggedIn(params)(`Saved authentication data to ${location}`);
        } else {
            await keytar.deletePassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(params));
            Logger.log(`Deleted authentication data from ${location}`);
        }
    }

    static async _loadFromFile(projectFolder) {
        const all = !projectFolder;

        if (!fs.existsSync(CONFIG.paths.settings)) {
            Logger.debug('Settings file absent');
            return emptyData(all);
        }

        Logger.debug('Reading settings file');
        const settingsByFolder = await fse.readJson(CONFIG.paths.settings);

        if (!settingsByFolder) {
            Logger.debug('Empty settings file');
            return emptyData(all);
        }

        if (all) { // return settings for all projects
            return settingsByFolder;
        }

        if (!settingsByFolder[projectFolder]) {
            Logger.debug(`No settings found for project ${projectFolder}`);
            return new ParamCollection();
        }

        return new ParamCollection(settingsByFolder[projectFolder]);
    }

    static async _loadAuthFromFile(appUrl, subdomain) {
        const all = !appUrl;

        if (!fs.existsSync(CONFIG.paths.auth)) {
            Logger.debug('Authentication-data file absent');
            return emptyData(all);
        }

        Logger.debug(`Reading authentication data from ${CONFIG.paths.auth}`);
        const allAuth = await fse.readJson(CONFIG.paths.auth);

        if (!allAuth) {
            Logger.debug('Empty authentication data');
            return emptyData(all);
        }

        if (all) { // return auth data for all projects
            return allAuth;
        }

        if (!allAuth[appUrl]) {
            Logger.debug(`No authentication data found for app URL ${appUrl}`);
            return new ParamCollection();
        }

        const authForSubdomain = allAuth[appUrl][subdomain];

        if (!authForSubdomain) {
            Logger.debug(`No authentication data found for subdomain ${subdomain}`);
            return new ParamCollection();
        }

        if (authForSubdomain.token) {
            authForSubdomain.tokenStorage = 'plain';
        }

        return new ParamCollection(authForSubdomain);
    }

    static async _loadAuthFromKeyring(appUrl, subdomain) {
        if (!keytar) {
            return new ParamCollection();
        }

        Logger.debug('Reading authentication data from keyring');

        const authString = await keytar.getPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(new ParamCollection({ appUrl, subdomain })));

        if (!authString) {
            Logger.debug(`No authentication data found for URL ${appUrl} and subdomain '${subdomain}'`);
            return new ParamCollection();
        }

        let auth;

        try {
            auth = JSON.parse(authString);
        } catch (error) {
            auth = {};
        }

        if (auth.token) {
            auth.tokenStorage = 'keyring';
        }

        return new ParamCollection(auth);
    }

}

module.exports = {
    SettingsManager,
    other
};
