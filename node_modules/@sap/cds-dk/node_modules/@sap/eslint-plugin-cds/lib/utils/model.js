/**
 * @typedef { import("eslint").AST.SourceLocation } SourceLocation
 */

const fs = require("fs");
const path = require("path");
const cds = require("@sap/cds");
const { SourceCode } = require("eslint");
const { isValidFile } = require("./helpers");

const cache = new Map();

module.exports = {
  /**
   * Simple cache to store model and any cds calls made in the rule creation
   * api to modify the model
   */
  Cache: {
    has(key) {
      return cache.has(key);
    },
    set(key, value) {
      return cache.set(key, [value, Date.now()]);
    },
    get(key) {
      return cache.get(key) ? cache.get(key)[0] : undefined
    },
    dump() {
      const dump = {};
      for (const [key, value] of cache.entries()) {
        const timestamp = new Date(value[1]);
        dump[key] = { key, value: JSON.stringify(value[0]), timestamp };
      }
      return dump;
    },
    remove(key) {
      if (cache.has(key)) {
        cache.delete(key);
      }
    },
    clear() {
      cache.clear();
    },
  },

  /**
   * Checks whether the path where the nearest ESLint configuration
   * file has changed
   * @param {*} configPath
   * @returns boolean
   */
  isNewConfigPath: function (configPath) {
    return !module.exports.Cache.has("configpath") 
            && (configPath !== module.exports.Cache.get("configpath"))
  },

  /**
   * Gets directory of the nearest ESLint config files associated
   * Within this plugin, this is equivalent to the cds project's directory
   * @param filePath
   * @returns Directory of ESLint config file
   */
  loadConfigPath: function (filePath) {
    let configPath = path.dirname(module.exports.getConfigPath(filePath));
    if (configPath) {
      module.exports.Cache.set("configpath", configPath);
    } else {
      throw new Error("Failed to find an ESLint configuration file!");
    }
    return configPath;
  },

  /**
   * Generates dummy AST with just single Program node
   * @param code Parse file contents
   * @returns AST
   */
  getAST: function (code) {
    return {
      type: "Program",
      body: [],
      sourceType: "module",
      tokens: [],
      comments: [],
      range: [0, code.length],
      loc: {
        start: {
          line: 1,
          column: 0,
        },
        end: {
          line: 1,
          column: 0,
        },
      },
    };
  },

  /**
   * Converts code with {line, column} to ESLint's 'range' property:
   * https://eslint.org/docs/developer-guide/working-with-custom-parsers#all-nodes
   * code.slice(node.range[0], node.range[1]) must be the text of the node!
   * @param code source code
   * @param line line number
   * @param column column number
   * @returns ESLint range
   */
  getRange: function (code, line, column) {
    const lines = typeof code === "string" ? SourceCode.splitLines(code) : code
    const ranges = [0];
    lines.forEach((line, i) => {
      ranges[i + 1] = i === 0 ? line.length + 1 : ranges[i] + line.length + 1
    });
    return line > 1 ? ranges[line - 1] + column : column
  },

  /**
   * Uses ESLint's static function splitLines() to split the source code text
   * into an array of lines:
   * https://eslint.org/docs/developer-guide/nodejs-api#sourcecodesplitlines
   * Returns the index of the last line
   * @param code
   * @returns Last line index
   */
  getLastLine: function (code) {
    const lines = typeof code === "string" ? SourceCode.splitLines(code) : code
    return lines.length - 1;
  },

  /**
   * Generates ESlint's 'loc' from artifact string and cds $location property:
   * https://eslint.org/docs/developer-guide/working-with-rules-deprecated#contextreport
   * @param name
   * @param {SoureLocation} obj
   * @returns ESLint's 'loc' object
   */
  getLocation: function (name, obj, model) {
    let loc;
    const defaultLoc = {
      start: { line: 0, column: 0 },
      end: { line: 1, column: 0 },
    };
    if (obj.$location) {
      const nameloc = obj.$location;
      if (nameloc) {
        // CSN entry with column 0 is equivalent to 'undefined'
        // It means that the column in that line cannot be determined,
        // so we assign a value 1 to get a column location of 0
        if (nameloc.col === 0) {
          nameloc.col = 1;
        }
        loc = defaultLoc;
        loc.start.column = nameloc.col - 1;
        loc.start.line = nameloc.line;
        loc.end.column = nameloc.col - 1 + name.length;
        loc.end.line = nameloc.line;
      } else if (obj.parent) {
          this.getLocation(name, obj.parent, model);
      }
    }
    // Empty locations default to line 0, column 0
    if (!loc) {
      loc = defaultLoc;
    }
    return loc;
  },

  /**
   * Searches for ESLint config file types (in order or precedence)
   * and returns corresponding directory (usually project's root dir)
   * https://eslint.org/docs/user-guide/configuring#configuration-file-formats
   * @param {string} currentDir start here and search until root dir
   * @returns {string} dir containing ESLint config file (empty if not exists)
   */
  getConfigPath: function (currentDir = ".") {
    const configFiles = [
      ".eslintrc.js",
      ".eslintrc.cjs",
      ".eslintrc.yaml",
      ".eslintrc.yml",
      ".eslintrc.json",
      ".eslintrc",
      "package.json",
    ];
    let configDir = path.resolve(currentDir);
    while (configDir !== path.resolve(configDir, "..")) {
      for (let i = 0; i < configFiles.length; i++) {
        const configPath = path.join(configDir, configFiles[i]);
        if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
          return configPath;
        }
      }
      configDir = path.join(configDir, "..");
    }
    return "";
  },

  /**
   * Compiles reflected model for a given project directory
   * Note, that to support monorepos, the cache (in @sap/cds) must be cleared
   * to also change the roots with every changed configPath.
   * @param configPath
   * @returns reflected model
   */
  compileModelFromPath: function (configPath) {
    let compiledModel;
    let reflectedModel;
    cds.resolve.cache = {};
    const roots = cds.resolve("*", { root: configPath });
    const messages = [];
    if (roots) {
      try {
      compiledModel = cds.load(roots, {
        cwd: configPath,
        sync: true,
        locations: true,
        messages,
      });
      module.exports.Cache.remove('errRootModel');
      } catch (err) {
        module.exports.Cache.set('errRootModel', err);
      }
      if (compiledModel) {
        reflectedModel = cds.linked(compiledModel);
        if (messages) {
          reflectedModel.messages = messages;
        }
      }
    }
    return reflectedModel;
  },

  /**
   * Compiles reflected model for a dictionary of files/file contents
   * Note, that this method is used to account for editor type events
   * and hence, model updates.
   * WARNING: Only use if cds roots are defined prior to this step
   * and the dictionary is complete (the compiler will not resolve
   * any missing files)!
   * @param dictFiles
   * @returns reflected model
   */
  compileModelFromDict: function (dictFiles, options) {
    let reflectedModel;
    const messages = [];
    const compiledModel = cds.compile(dictFiles, {
      sync: true,
      locations: true,
      messages,
      ...options,
    });
    if (compiledModel) {
      reflectedModel = cds.linked(compiledModel);
      if (messages) {
        reflectedModel.messages = messages;
      }
    }
    return reflectedModel;
  },

  compileModelFromFile: function (code, filePath) {
    let compiledModel;
    let reflectedModel;
    const dictFiles = {};
    dictFiles[filePath] = code;
    let flavor = "inferred";
    try {
      compiledModel = module.exports.compileModelFromDict(dictFiles, {
        flavor,
      });
    } catch (err) {
      // Supress errors from parked files
    }
    if (compiledModel) {
      reflectedModel = cds.linked(compiledModel);
    }
    return reflectedModel;
  },

  /**
   * Initiates and stores new reflected model, it's corresponding project path,
   * as well as a list and dictionary of files comprising the model.
   * @param configPath
   * @param filePath
   */
  initRootModel: function (configPath) {
    module.exports.Cache.set("configpath", configPath);
    const reflectedModel = module.exports.compileModelFromPath(configPath);
    module.exports.Cache.set(`model:${configPath}`, reflectedModel);
    let files;
    if (reflectedModel && reflectedModel.$sources) {
      files = reflectedModel.$sources;
      if (files) {
        module.exports.Cache.set(`modelfiles:${configPath}`, files);
      } else {
        files = [];
      }
      const dictFiles = module.exports.getDictFiles(configPath, files);
      module.exports.Cache.set(`dictfiles:${configPath}`, dictFiles);
    }
    return reflectedModel;
  },

  /** 
   * Creates a model for ESLint unit tests
   */
  initModelRuleTester: function (filePath) {
    module.exports.Cache.set("test", true);
    const configPath = path.dirname(filePath);
    module.exports.Cache.set('configpath', configPath);
    let files = fs.readdirSync(configPath);
    const modelfiles = files.map(f => path.join(configPath, f))
                            .filter(fp => isValidFile(fp, 'MODEL_FILES'))
    module.exports.Cache.set(`modelfiles:${configPath}`, modelfiles);
    const dictFiles = module.exports.getDictFiles(configPath, modelfiles);
    module.exports.Cache.set(`dictfiles:${configPath}`, dictFiles);
    const reflectedModel = module.exports.compileModelFromDict(dictFiles);
    module.exports.Cache.set(`model:${configPath}`, reflectedModel);
  },

  /**
   * Creates or updates a dictionary of files/file contents for a given
   * project path.
   * @param configPath
   * @param files
   * @returns dictFiles
   */
  getDictFiles: function (input, files = []) {
    let dictFiles = {};
    if (module.exports.Cache.has(`dictfiles:${input}`)) {
      dictFiles = module.exports.Cache.get(`dictfiles:${input}`);
    } else {
      files.forEach((file) => {
        dictFiles[file] = module.exports.Cache.has(`file:${file}`)
                          ? module.exports.Cache.get(`file:${file}`)
                          : fs.readFileSync(file, "utf8")
      });
    }
    return dictFiles;
  },

  /**
   * Determines whether an incoming file has changed contents
   * @param context cds context object
   * @returns boolean
   */
  hasFileChanged: function (code, filePath, configPath) {
    let result = false
    const files = module.exports.Cache.get(`modelfiles:${configPath}`);
    const dictFiles = module.exports.getDictFiles(configPath, files);
    const isFileInModel = module.exports.isFileInModel(filePath, configPath);
    // If incoming file is a 'model' file
    if (isFileInModel) {
      // Only update on detected changes
      if (dictFiles[filePath] !== code) {
        dictFiles[filePath] = code;
        module.exports.Cache.set(`dictfiles:${configPath}`, dictFiles);
        result = true
      }
    } else if (dictFiles[filePath] !== code) {
        result = true
    }
    return result;
  },

  /**
   * Checks whether a file is part of the model for a given project
   * @param context
   * @param files
   * @returns boolean
   */
  isFileInModel(filePath, configPath) {
    let files = module.exports.Cache.get(`modelfiles:${configPath}`) || [];
    return files && files.length > 0 && files.includes(filePath)
  },

  /**
   * Updates and stores reflected model on file changes. Model compilation
   * us handled separately for 'model' files (part of model) and 'outsider'
   * files.
   * @param context cds context object
   */
  updateModel: function (code, filePath, configPath) {
    let reflectedModel;
    const dictFiles = module.exports.Cache.get(`dictfiles:${configPath}`);
    dictFiles[filePath] = code;
    module.exports.Cache.set(`dictfiles:${configPath}`, dictFiles);
    reflectedModel = module.exports.compileModelFromDict(dictFiles, { flavor: "inferred" });
    if (reflectedModel) { module.exports.Cache.remove('errRootModel') }
    module.exports.Cache.set(`model:${configPath}`, reflectedModel);
    return reflectedModel;
  }

};
