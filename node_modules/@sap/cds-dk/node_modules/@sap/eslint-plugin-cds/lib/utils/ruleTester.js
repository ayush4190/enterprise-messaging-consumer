const fs = require("fs");
const path = require("path");

const { RuleTester } = require("eslint");
const { Cache, initModelRuleTester } = require("./model");
const { createRule, getRules } = require("./rules");
const { isValidFile } = require("./helpers");

module.exports = {
/**
 * ESLint RuleTester (used by custom rule creator api)
 * Calls ESLint's RuleTester with custom cds parser and input for
 * valid/invalid checks:
 * Model checks require input 'code' entries
 * Env checks require input 'options' with selected parameters
 * @param {CDSRuleTestOpts} options RuleTester input options
 * @returns RuleTester results
 */
runRuleTester: function(options) {
    let parser;
    let rule = {};
    const rulename = path.basename(options.root);
    const plugin = "eslint-plugin-cds";
    if (options.root.includes(plugin)) {
      // For plugin's internal tests, resolve parser from here
      parser = require.resolve("../parser");
      const pluginPath = path.join(path.dirname(options.root), "../..");
      rule = createRule(require(`../rules/${path.basename(options.root)}`));
      Cache.set(
        "rulesInfo",
        getRules(path.join(path.dirname(options.root), "../../lib/rules"), rulename)
      );
      Cache.set("pluginpath", pluginPath);
    } else {
      // Otherwise from project root
      const resolvedPlugin = require.resolve("@sap/eslint-plugin-cds", {
        paths: [options.root],
      });
      parser = path.join(path.dirname(resolvedPlugin), "parser");
      rule = require(path.join(
        options.root,
        `../../rules/${path.basename(options.root)}`
      ));
      const pluginPath = path.join(path.dirname(options.root), "../../../..");
      Cache.set("rulesInfo", getRules(path.join(options.root, "../../rules", rulename)));
      Cache.set("pluginpath", pluginPath);
    }
    let tester = new RuleTester({});
    if (parser) {
      tester = new RuleTester({ parser });
    }
    const testerCases = {};
    ["valid", "invalid"].forEach((type) => {
      const filePath = path.join(options.root, `${type}/${options.filename}`);
      const model = initModelRuleTester(filePath);
      testerCases[type] = [
        {
          filename: filePath,
        },
      ];
      if (!isValidFile(options.filename, 'FILES')) {
        const fileContents = JSON.parse(fs.readFileSync(filePath, "utf8"));
        testerCases[type][0].code = "";
        testerCases[type][0].options = [{ environment: fileContents }];
      } else {
        testerCases[type][0].code = fs.readFileSync(filePath, "utf8");
        testerCases[type][0].options = [{ model }];
      }
      if (type === "invalid") {
        testerCases[type][0].errors = options.errors;
        const fileFixed = path.join(options.root, `fixed/${options.filename}`);
        if (fs.existsSync(fileFixed) && rule.meta.type !== "suggestion") {
          testerCases[type][0].output = fs.readFileSync(fileFixed, "utf8");
        }
      }
    });
    return tester.run(rulename, rule, testerCases);
  }
}
