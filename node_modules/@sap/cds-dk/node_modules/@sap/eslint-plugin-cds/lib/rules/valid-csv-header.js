const {basename, extname} = require('path')
const findFuzzy = require('../utils/fuzzySearch')
const SEP = '[,;\t]'
const EOL = '\\r?\\n'

module.exports = {
  meta: {
    docs: {
      description: `CSV files for entities must refer to valid element names.`,
      category: "Model Validation",
      recommended: true,
      version: "2.3.0",
    },
    severity: "warn",
    type: "problem",
    hasSuggestions: true,
    messages: {
      InvalidColumn: `Invalid column '{{column}}'. Did you mean '{{candidates}}'?`,
      ReplaceColumnWith: `Replace '{{column}}' with '{{candidates}}'`
    }
  },
  create: function (context) {

    return { all: check_valid_headers }

    function check_valid_headers() {
    const reports = [];
    const {cds, code, filePath, sourcecode} = context;

    if (!filePath.endsWith('.csv')) return
    if (!cds.model)  return
    let { env, model } = cds;
    model = cds.compile.for.sql(model, { names:env.sql.names, messages: [] } )

    const filename = basename(filePath)
    const entityName = filename.replace(/-/g,'.').slice(0, -extname(filename).length)
    const entity = _entity4(entityName, model);
    if (!entity)  return

    const elements = Object.values(entity.elements)
      .filter (e => !!e['@cds.persistence.name'])
      .map (e => e['@cds.persistence.name'].toUpperCase())

    const [ cols ] = cds.parse.csv(code);
    const missing = cols.filter (col => !elements.includes(col.toUpperCase()))
    missing.forEach(miss => {
      const index = _findInCode (miss, code)
      const loc = sourcecode.getLocFromIndex(index)
      const candidates = findFuzzy(miss, Object.keys(entity.elements).sort())
      const suggest = candidates.map(cand => { return {
        messageId: 'ReplaceColumnWith',
        data: {column: miss, candidates:cand},
        fix: (fixer) => fixer.replaceTextRange([index, index+miss.length], cand)
      }})
      reports.push({
        messageId: 'InvalidColumn',
        data: {column: miss, candidates},
        loc: {start: loc, end: {line: loc.line, column: loc.column+miss.length}},
        file: filePath,
        suggest
      })
    })
    return reports
    }

  }

}

function _findInCode (miss, code) {
  // middle
  let match = new RegExp(SEP+miss+SEP).exec(code)
  if (match)  return match.index+1
  // end of line
  match = new RegExp(SEP+miss+EOL).exec(code)
  if (match)  return match.index+1
  // start of doc
  match = new RegExp('^'+miss+SEP).exec(code)
  if (match)  return match.index
  // somewhere (fallback)
  return code.indexOf(miss)
}

function _entity4 (name, csn) {
  let entity = csn.definitions [name]
  if (!entity) {
    if (/(.+)[._]texts_?/.test (name)) { // 'Books.texts', 'Books.texts_de'
      const base = csn.definitions [RegExp.$1]
      return base && _entity4 (base.elements.texts.target, csn)
    }
    else return
  }
  // we also support simple views if they have no projection
  const p = entity.query && entity.query.SELECT || entity.projection
  if (p && !p.columns && p.from.ref && p.from.ref.length === 1) {
    if (csn.definitions [p.from.ref[0]])  return entity
  }
  return entity.name ? entity : { name, __proto__:entity }
}

