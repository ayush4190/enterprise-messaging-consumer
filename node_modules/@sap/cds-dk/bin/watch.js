const watchOnlyOptions = ['--ext', '--livereload', '--open']
module.exports = Object.assign ( watch, {
  flags: [ '--debug', '--in-memory', '--in-memory?', '--with-mocks' ],
  options: [ '--port', ...watchOnlyOptions ],
  help: `
# SYNOPSIS

  *cds watch* [<project>]

  Tells cds to watch for relevant things to come or change in the specified
  project or the current work directory. Compiles and (re-)runs the server
  on every change detected.

# OPTIONS

  *--port* <number>

    Specify the port on which the launched server listens.
    If you specify '0', the server picks a random free port.
    Alternatively, specify the port using env variable _PORT_.

  *--ext* <extensions>

    Specify file extensions to watch for in a comma-separated list.
    *Example:* cds w --ext cds,json,js.

  *--livereload* <port | false>

    Specify the port for the livereload server. Defaults to '35729'.
    Disable it with value _false_.

  *--open* <url>

    Open the given URL (suffix) in the browser after starting.
    If none is given, the default application URL will be opened.

# SEE ALSO

  Actually, *cds watch* is just a convenient shortcut for:
  *cds serve* all --with-mocks --in-memory? ...
  Check out *cds serve ?* to learn more.

`})

const DEBUG = /\bwatch\b/.test(process.env.DEBUG) && console.debug
const {delimiter,dirname,relative,resolve,sep} = require ('path')
const fs = require ('fs')
const t = module.exports.codes = {
  reset: '\x1b[0m', // Default
  bold: '\x1b[1m', // Bold/Bright
  link: '\x1b[4m', // underline
  red: '\x1b[91m', // Bright Foreground Red
  green: '\x1b[32m', // Foreground Green
  yellow: '\x1b[33m', // Foreground Green
  orange: '\x1b[38;2;255;140;0m' // darker orange, works with bright and dark background
}
const extDefaults = 'cds,csn,csv,ts,mjs,cjs,js,json,properties,edmx,xml,env'
let ignore = /node_modules|target|\.cds-services\.json$/

async function watch ([cwd], {
  args = ['serve', 'all'],
  ext = extDefaults,
  ...options
}={}) {
  if (!Object.keys(options).includes('with-mocks'))               args.push ('--with-mocks')
  if (!Object.keys(options).find(a => /^in-memory\??$/.test(a)))  args.push ('--in-memory?')
  args
    .push (...(process.argv.slice(3).filter(a => !args.includes(a)))  // add deduped command line args
    .filter(removeArgsIn(watchOnlyOptions))  // remove all watch-only options, as `cds serve` would not accept them
    .filter(a => a !== '--watch')            // from `cds serve --watch`
    .filter(a => a !== cwd))

  let env = Object.assign (process.env, {
    _args: JSON.stringify(args),
    _options: JSON.stringify(options)
  })

  // allow running w/o or partial local node_modules, also add cds-dk for its sqlite
  env.NODE_PATH = [...paths(cwd||process.cwd()), ...paths(__dirname)].join(delimiter)

  if (typeof ext !== 'string')  ext = extDefaults

  let liveReload //= ...
  let firstTime = true
  if (!/false|no/.test(options['livereload'])) {
    ext += ',css,gif,html,jpg,png,svg'
    liveReload = new (require ('../lib/watch/livereload-server'))
    env.CDS_LIVERELOAD_PATH = require.resolve ('connect-livereload')
    env.CDS_LIVERELOAD_URL = await liveReload.start (options['livereload'])
      .catch(err => { console.log(`Error starting live reload: ${err.message}`); liveReload = null })
  } else {
    ignore = RegExp(`app${sep}.*\\.(js|ts)|`+ignore.source) // exclude more frontend stuff
  }

  const log = (first,...more) => console.log (t.yellow + (first||''), ...more, t.reset)
  if (cwd) {
    const ocwd = process.env._original_cwd = process.cwd()
    if (fs.existsSync(cwd)) log (`cd ${cwd}`)
    else try {
      const resolved = dirname (require.resolve(cwd+'/package.json', {paths:[ocwd]}))
      log (`cd ${relative(ocwd,cwd = resolved)}`)
    } catch(_){ throw new Error(`No such folder or package: '${ocwd}' -> '${cwd}'`) }
  }
  log ()
  log (`${t.bold}cds ${args.join(' ')}`)
  log (`watching: ${ext}...`)
  if (liveReload) log (`live reload enabled for browsers`)

  const bindingManager = new require('../lib/bind/bindingResolver').bindingManager({cwd})
  const bindings = await bindingManager.resolve()
  if (bindings) env = {...env, 'CDS_REQUIRES': JSON.stringify(bindings.requires)}

  const nodemon = require('../lib/watch/node-watch')
  const watcher = nodemon ({
    watch: ['*','.env','.cdsrc.json'],
    script:__filename, cwd, env, ext, ignore,
    delay: parseInt(process.env.CDS_WATCH_DELAY) || 200,
    options
  }).on('restart', (files)=>{
    DEBUG && DEBUG (files)
    if (liveReload) liveReload.markPending(files)
    if (this.delayed) clearTimeout (this.delayed)
    this.delayed = setTimeout(()=>{
      bindingManager.update({
        onBeforeUpdate: () => watcher.stop(),
        onAfterUpdate: bindings => {
          watcher.setEnv('CDS_REQUIRES', bindings && JSON.stringify(bindings.requires))
          watcher.restart()
        }
      })
      log (`${t.bold}        _______________________\n`)
      FileHandlers.changed (files,cwd)
    }, 111)
  }).on('quit', ()=>{
    log (`${t.bold+t.green}\n[cds] - my watch has ended.\n`)
  }).on('message', async (msg) => { switch (msg.code) { // messages from child process
    case 'listening':
      env.PORT = (msg.address && msg.address.port) || msg.port
      liveReload && liveReload.reload()
      firstTime && options['open'] && require('../lib/watch/open').openURL (options['open'], env.PORT)
      firstTime = false
      break
    case 'EADDRINUSE': env.PORT = 0; _addr_in_use(msg); break
    default: console.error (msg)
  }})

  return watcher
}


const _addr_in_use = (msg) => console.error (`
  ${t.red+t.bold}[EADDRINUSE]${t.reset} - port ${msg.port} is already in use by another server process.
  > Press Return to restart with an arbitrary port.
`)

const FileHandlers = {
  edmx: [ (...args) => (FileHandlers._import || (FileHandlers._import = require ('./import'))) (...args) ],
  changed (files,cwd) {
    if (files) for (let each of files) {
      const [,ext] = /\.(\w+)$/.exec(each) || []
      for (let handle of this[ext] || [])  handle (each,{into:cwd})
    }
  },
}

function removeArgsIn (toRemove) {
  let argRemoved = false
  return arg => { // filter function
    if (toRemove.includes(arg)) {
      argRemoved = true
      return false
    }
    else if (argRemoved) {  // if next arg is a value, skip it as well
      argRemoved = false
      if (!arg.startsWith('-'))  return false
    }
    return true
  }
}

// builds paths from dir + its parent node_modules
function paths (dir) {
  const parts = resolve(dir).split(sep), n = parts.length, nm = sep+'node_modules'
  return parts.map ((_,i,a)=> a.slice(0,n-i).join(sep)+nm).filter(p => fs.existsSync(p))
}

//
// Child process impl launched by watch
//

if (!module.parent) (async()=>{ // launched by nodemon
  // run through cli in order to use its error handling
  const bootstrap = require('./cds')(...JSON.parse(process.env._args))
  const {cds} = global

  cds.once('listening', ({server, url}) => {
    process.send ({ code:'listening', port: server.address().port })
    // Need to give bindings an explicit call to purge,
    // as its .exit handler has no chance to execute on Windows.
    process.on ('message', (msg)=> { if (msg && msg.exit) { // see node-watch
      (new cds.service.bindings(url)).purge()
    }})
  })

  try {
    await bootstrap
    if (!cds.service.providers.length) return _no_services_found()
  } catch (e) { switch (e.code) {
    case 'NO_SERVICES_FOUND': return _no_services_found(e)
    case 'MODEL_NOT_FOUND': return _no_models_found(e)
    case 'EADDRINUSE': return process.send(e)  //> tell cds watch
    default: { throw e } // cli error handling will catch and format
  }}
  function _no_models_found(e) { console.log (`
    No models found in ${cds.resolve(e.model||'*',false)}.
    Waiting for some to arrive...
  `)}
  function _no_services_found() { console.log (`
    No service definitions found in loaded models.
    Waiting for some to arrive...
  `)}
})()
