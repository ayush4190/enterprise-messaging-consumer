
module.exports = Object.assign(_import, {
    _name: 'import',
    options: ['--out', '--into', '--as', '--include-namespaces'],
    flags: ['--dry', '--force', '--no-copy', '--no-save', '--keep-namespace'],
    shortcuts: ['-o', '-in', '-as', '-ns', '-', '-f'],
    help: `
# SYNOPSIS

    *cds import* <source> [<options>]

    Imports the given source and converts it to CSN.
    Currently only OData EDMX input is supported.

    Without any options the source is copied to ./srv/external and the csn
    output written next to it. Finally it will add an entry for the imported
    service to package.json#cds.requires.


# OPTIONS

    *--no-copy*
        Skips copying to ./srv/external.

    *--no-save*
        Skips updating ./package.json.

    *--keep-namespace*
        Keeps the original namespace from the edmx content instead of using
        the filename by default.

    *-in | --into* <filename>
        Skips copying to ./srv/external and writes to the specified location.

    *-o | --out* <filename>
        Skips copying to ./srv/external and writes to the specified location.

    *- | --dry*
        Writes the converted csn to stdout only.

    *-as | --as <output_file_format>*
        Converts the input edmx or xml file into one of these supported formats "cds", "csn", "json"

    *-f | --force*
        Forcefully overwrites the contents in the CDS file and updates the checksum
        
    *-ns | --include-namespaces <string_of_namespaces> or* "\x2A"
        Imports only entities matching to the given list of namespaces.
        For OData V2 attributes with the namespace "sap" & "m" are captured by default.

       

# EXAMPLES

    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import - ~/Downloads/API_BUSINESS_PARTNER.edmx
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --as cds
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "sap,c4c"
    cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --include-namespaces "\x2A"

`})
const cds = require('@sap/cds/lib')
const { fs, path, write, mkdirp, exists, read} = cds.utils
const edm2csn = require('../lib/import')
const messages = require('../lib/import/message').getMessages();
const common = require('../lib/import/common');
const cdsCompiler = require('../lib/compile').compile.to;
const md5 = require('md5');
let cwd;
async function _import(file, { out, dry, into, as, 
    'include-namespaces': include_namespaces,
    'no-save': no_save,
    'no-copy': no_copy,
    'keep-namespace': keep_namespace,
    force
} = {}) {
    if (!as) {
        if (cds.env.import) as = cds.env.import.as;
    }
    if (!include_namespaces) {
        if(cds.env.import) include_namespaces = cds.env.import.include_namespaces;
    }
    cwd = into || process.cwd();
    if (as && !common.supportedFormats().includes(as)) 
        throw new Error(messages.INVALID_AS_OPTION);
    if (Array.isArray(file)) file = file[0]
    if (!file) return this.help('import')
    file = await edm2csn.isValidInputFile(path.resolve(cwd, file))
    const external = path.resolve(cwd, 'srv/external')
    const dst = path.join(external, path.basename(file))
    if (!dry && !no_copy) file = await _copy_to_srv_external(file, dst)
    const src = await edm2csn.getMetadataFromFile(file)
    this.include_all_namespaces = false;
    let namespaces = [];
    if(include_namespaces) {
        if(include_namespaces === "*") this.include_all_namespaces = true;
        else if(typeof include_namespaces === 'string' && !include_namespaces.startsWith('-')) namespaces = include_namespaces.replace(/ /g, "").split(',');
        else throw new Error(messages.INCORRECT_INPUT_NAMESPACES);
    }
    this.namespaces = namespaces;
    let csn = await edm2csn.edmx2csn(src, !keep_namespace && file, this)
    const service = _service_name_from(csn);
    if (out) out = edm2csn.validateAndComputeOutputFilePath(out, as);
    const result = await _getResult(csn, service, as, out || dst.replace(/\.[^.]+$/, ''), force);
    const written = dry || await _write(result[0], result[1], result[2]);
    const registered = dry || no_save || await _update_package_json(result[1].replace(/\.[^.]+$/, ''), service, this.oDataVersion);
    if (dry) return console.log(result[0]);
    return Promise.all([written, registered])
}

async function _generateChecksumValidate(dest, output, force) {
    let fileExists = await exists(dest);

    // force flag disabled and cds file already exists, then throw error
    if (!force && fileExists) {
        throw new Error(messages.FILE_MODIFIED);
    }

    const currentChecksum = md5(output);
    let existingFileContent, existingFileContentWithoutChecksum;
    let existingFileContentChecksum, existingChecksumValue;

    if (fileExists) {
        existingFileContent = await read(dest, "utf-8");
        const checksumStartIndex = existingFileContent.indexOf(`/* checksum : `);
        const checksumEndIndex = existingFileContent.indexOf(" */");

        if (checksumStartIndex >= 0) {
            existingFileContentWithoutChecksum = existingFileContent.substring(
                checksumEndIndex + 4
            );
            existingChecksumValue = existingFileContent.substring(
                checksumStartIndex + 14, checksumEndIndex
            );
            existingFileContentChecksum = md5(existingFileContentWithoutChecksum);
        }
    }

    // if force flag enbabled
    if (force) {
        // current and existing file content are same, and the existing
        // checksum is not modified, then return the existing file content
        if (currentChecksum == existingFileContentChecksum && 
            currentChecksum == existingChecksumValue) {
            return existingFileContent;
        }
    } 
    /*
     * 1. current and existing checksum are different.
     * 2. checksum is missing in the existing file:
     *     a. existing and current file content are same.
     *     b. existing and current file content are different.
     * 3. cds file doesn't exist.
     * 4. checksum of the existing file is modified.
     */
    return "/* checksum : " + currentChecksum + " */\n" + output;
}

async function _getResult(output, service, as, dest, force) {
    let using, message, extension;
    as = (as === "cds") ? "cdl" : as;

    if (!common.supportedFormats().includes(extension = dest.substring(dest.lastIndexOf(".") + 1))) {
        // dest doesn't have any file extension, so get it
        extension = common.getSuffix(as);
    } 

    dest = dest.replace('.' + extension, '');
    using = `using { ${service} as external } from './${path.relative('srv', dest).replace(/\\/g, '/')}'`;
    using = require('../lib/util/term').info(using);    
    message = `[cds] - imported API to ${path.relative(cwd, dest)}
> use it in your CDS models through the like of:

${using}
`;

    dest += '.' + extension;

    if (as && as != "csn" && as != "json") {
        // cdsCompiler[as] will convert the csn output into various output formats
        output = cdsCompiler[as](output);
    }

    switch(as) {
        case "cdl":
            output = await _generateChecksumValidate(dest, output, force);
            break;
        case undefined:
        case "csn":
        case "json":
            output = JSON.stringify(output, null, '  ');
            break;
        default:
            break;
    }

    return [output, dest, message];
}

async function _write(output, dest, message) {
    await edm2csn.saveCSNModel(output, dest);
    console.log(message);
}

async function _copy_to_srv_external(file, dst) {
    const dstDir = path.dirname(dst), srcDir = path.dirname(file)
    if (!file.startsWith(dstDir + path.sep)) {
        await mkdirp(dstDir)
        const copy_or_move = srcDir === cwd || srcDir == process.cwd() ? fs.renameSync : fs.copyFileSync
        await copy_or_move(file, dst)
        return dst
    }
    return file
}

function _service_name_from(csn) {
    for (let each in csn.definitions) {
        if (csn.definitions[each].kind === 'service') return each
    }
}

async function _update_package_json(dest, service, version) {
    const package_json = path.resolve(cwd, 'package.json')
    const conf = await exists(package_json) ? require(package_json) : {}
    const requires = ['cds', 'requires'].reduce((p, n) => p[n] || (p[n] = {}), conf)
    if (!requires[service]) {
        const model = path.relative(cwd, dest)
        cds.env.requires[service] = requires[service] = { kind: (version === "V2") ? 'odata-v2' : 'odata', model }
        await write(package_json, JSON.stringify(conf, null, '  '))
        console.log(`[cds] - updated ./package.json`)
    }
}